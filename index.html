<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>First-Person Weapon Viewer</title>
    <!-- Load Three.js core library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- Load GLTFLoader to handle .glb files -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <style>
        /* General styling for the full-screen canvas */
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Inter', sans-serif;
            color: #ffffff;
            /* Create a simple sky background color */
            background-color: #87ceeb; /* Light Sky Blue */
        }
        canvas {
            display: block;
        }

        /* Styling for the loading message and switch button */
        #ui-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none; /* Allows clicks to pass through by default */
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-end; /* Align elements to the bottom */
            padding-bottom: 20px;
            z-index: 10;
        }
        
        #loading-message {
            background: rgba(0, 0, 0, 0.7);
            padding: 15px 30px;
            border-radius: 8px;
            font-size: 1.2em;
            pointer-events: auto;
            margin-bottom: 10px;
        }

        #switch-button {
            pointer-events: auto; /* Make the button clickable */
            background-color: #4CAF50; /* Green */
            color: white;
            padding: 10px 20px;
            text-align: center;
            text-decoration: none;
            display: inline-block;
            font-size: 16px;
            margin: 4px 2px;
            cursor: pointer;
            border-radius: 12px;
            border: none;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            transition: background-color 0.3s, transform 0.1s;
        }

        #switch-button:hover {
            background-color: #45a049;
            transform: translateY(-1px);
        }

        #instructions {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 5px;
            font-size: 0.9em;
            color: #fff;
            pointer-events: none;
        }
    </style>
</head>
<body>
    <div id="ui-container">
        <div id="loading-message">Loading models...</div>
        <button id="switch-button" style="display: none;">Switch Weapon (Axe)</button>
    </div>
    <div id="instructions">
        WASD to Move | Mouse to Look Around
    </div>
    
    <script type="module">
        // Import necessary components from the global THREE object
        const { 
            Scene, PerspectiveCamera, WebGLRenderer, DirectionalLight, HemisphereLight, 
            GLTFLoader, Clock, Group, Vector3, Mesh, PlaneGeometry, MeshStandardMaterial
        } = THREE;

        // Global variables
        let scene, camera, renderer, loader;
        let weaponGroup; // Group to hold the current weapon model
        let currentModelIndex = 0; // Index to cycle through models
        const modelNames = ['BattleAxe', 'Sword', 'Pickaxe']; // List of model names
        let models = {}; // Object to store loaded model data: { 'BattleAxe': gltfScene, 'Sword': gltfScene, 'Pickaxe': gltfScene }
        let isLoaded = false;
        
        const loadingMessage = document.getElementById('loading-message');
        const switchButton = document.getElementById('switch-button');
        const clock = new Clock();
        
        // Movement Variables
        let moveForward = false;
        let moveBackward = false;
        let moveLeft = false;
        let moveRight = false;
        const velocity = new Vector3();
        const direction = new Vector3();
        const cameraPitch = new Group(); // For vertical camera rotation

        // Mouse look sensitivity
        const lookSensitivity = 0.002;
        let yaw = 0;
        let pitch = 0;

        // 1. Initialization
        function init() {
            // Scene setup
            scene = new Scene();
            scene.background = new THREE.Color(0x87ceeb); // Blue sky background

            // Camera setup
            camera = new PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 1.6, 0); // Average human height

            // Setup camera pitch group for vertical rotation (mouse look)
            camera.add(cameraPitch); 
            scene.add(camera);

            // Weapon Group: Attached to the cameraPitch group so it moves with the view
            weaponGroup = new Group();
            cameraPitch.add(weaponGroup);
            
            // Renderer setup
            renderer = new WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.0; 
            renderer.outputEncoding = THREE.sRGBEncoding;
            
            document.body.appendChild(renderer.domElement);

            // 2. Lighting Setup
            const hemiLight = new HemisphereLight(0xffffff, 0x00ff00, 0.8); // Adjusted ground color for green reflection
            hemiLight.position.set(0, 50, 0);
            scene.add(hemiLight);

            const dirLight = new DirectionalLight(0xffffff, 1.5); 
            dirLight.position.set(5, 20, 10);
            dirLight.castShadow = true;
            dirLight.shadow.mapSize.width = 1024;
            dirLight.shadow.mapSize.height = 1024;
            dirLight.shadow.camera.near = 0.5;
            dirLight.shadow.camera.far = 50;
            scene.add(dirLight);

            // 3. Infinite Green Flat Ground
            const ground = new Mesh(
                new PlaneGeometry(1000, 1000), // Large plane for 'infinite' look
                new MeshStandardMaterial({ color: 0x228B22 }) // Forest Green color
            );
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);
            
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap; 

            // 4. Load Models
            loader = new GLTFLoader();
            // FIX: Use relative paths for external hosting (like GitHub Pages)
            loadModel('BattleAxe.glb', 'BattleAxe');
            loadModel('Sword.glb', 'Sword');
            loadModel('Pickaxe.glb', 'Pickaxe'); // ADDED NEW MODEL

            // 5. Setup Controls
            setupKeyboardControls();
            setupMouseLook();
        }

        // Function to handle GLB loading
        function loadModel(filePath, name) {
            loader.load(
                filePath,
                function (gltf) {
                    gltf.scene.traverse(function (child) {
                        if (child.isMesh) {
                            child.castShadow = true;
                            child.receiveShadow = false;
                        }
                    });

                    models[name] = gltf.scene;

                    // Check if all models (3 total) are loaded
                    if (Object.keys(models).length === modelNames.length) {
                        isLoaded = true;
                        loadingMessage.style.display = 'none';
                        switchButton.style.display = 'block';
                        attachWeapon(modelNames[currentModelIndex]);
                    }
                },
                function (xhr) {
                    const loadedCount = Object.keys(models).length;
                    const totalModels = modelNames.length;
                    const overallProgress = (loadedCount / totalModels) * 100 + (xhr.loaded / xhr.total) * (100 / totalModels);

                    loadingMessage.textContent = `Loading... (${Math.floor(overallProgress)}%)`;
                },
                function (error) {
                    console.error(`An error occurred while loading ${name}:`, error);
                    // Crucial fix: The CORS error indicates these paths are not working externally. 
                    // Tell the user where to put the files.
                    loadingMessage.textContent = `Error loading ${name}. CORS/path error. Ensure "${filePath}" is in the same directory as index.html.`;
                }
            );
        }

        // Function to attach and position the weapon in first-person view
        function attachWeapon(name) {
            // 1. Clear the weaponGroup
            while(weaponGroup.children.length > 0){
                weaponGroup.remove(weaponGroup.children[0]);
            }

            const modelScene = models[name];
            
            // 2. Set the transform for first-person hold
            // Note: We use rotation.x for the "hold" angle, rotation.y for yaw (0.1 for slight rotation), and rotation.z for roll.
            // These values are optimized for a good first-person feel.
            let scale = 1.5;
            let position = new Vector3(0.6, -0.7, -1.0);
            
            // Adjustments for the Pickaxe to fit the screen better
            if (name === 'Pickaxe') {
                scale = 2.0; 
                position.set(0.7, -0.8, -1.2); 
            }

            modelScene.rotation.set(-0.5, Math.PI / 2 + 0.1, 0.5); 
            modelScene.position.copy(position); 
            modelScene.scale.set(scale, scale, scale); 
            
            weaponGroup.add(modelScene);
            
            // Update button text to show the next weapon
            const nextIndex = (currentModelIndex + 1) % modelNames.length;
            switchButton.textContent = `Switch Weapon (${modelNames[nextIndex]})`;
        }
        
        // 4. Handle Weapon Switching
        switchButton.addEventListener('click', () => {
            if (!isLoaded) return;
            
            // Cycle to the next model
            currentModelIndex = (currentModelIndex + 1) % modelNames.length;
            const nextWeapon = modelNames[currentModelIndex];
            
            attachWeapon(nextWeapon);
        });

        // ===================================
        // FIRST-PERSON CONTROL IMPLEMENTATION
        // ===================================

        function setupKeyboardControls() {
            document.addEventListener('keydown', onKeyDown, false);
            document.addEventListener('keyup', onKeyUp, false);
        }

        function onKeyDown(event) {
            switch (event.code) {
                case 'KeyW': moveForward = true; break;
                case 'KeyA': moveLeft = true; break;
                case 'KeyS': moveBackward = true; break;
                case 'KeyD': moveRight = true; break;
            }
        }

        function onKeyUp(event) {
            switch (event.code) {
                case 'KeyW': moveForward = false; break;
                case 'KeyA': moveLeft = false; break;
                case 'KeyS': moveBackward = false; break;
                case 'KeyD': moveRight = false; break;
            }
        }
        
        function setupMouseLook() {
            // Note: Since pointer lock might not work in all sandbox environments, 
            // we attach mousemove to the entire document.
            document.addEventListener('mousemove', onMouseMove, false);
        }

        function onMouseMove(event) {
            // Horizontal rotation (Yaw) on the camera (x-axis)
            yaw -= event.movementX * lookSensitivity;
            camera.rotation.y = yaw; 

            // Vertical rotation (Pitch) on the cameraPitch group
            pitch -= event.movementY * lookSensitivity;
            // Clamp the pitch rotation to prevent flipping the view
            pitch = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, pitch));
            cameraPitch.rotation.x = pitch;
        }

        // Movement update logic
        function updateMovement(delta) {
            const speed = 5.0; // Movement speed

            // Dampen velocity for smooth stop
            velocity.x -= velocity.x * 10.0 * delta;
            velocity.z -= velocity.z * 10.0 * delta;
            
            // Set movement direction
            direction.z = Number(moveForward) - Number(moveBackward);
            direction.x = Number(moveRight) - Number(moveLeft);
            direction.normalize(); 

            // Apply acceleration
            if (moveForward || moveBackward) velocity.z -= direction.z * speed * delta;
            if (moveLeft || moveRight) velocity.x -= direction.x * speed * delta;

            // Translate camera based on velocity
            // Move camera forward/backward relative to its current rotation (yaw)
            camera.translateX(velocity.x * delta);
            camera.translateZ(velocity.z * delta);
            
            // Keep player on the ground (y=1.6)
            camera.position.y = 1.6; 
        }

        // 5. Animation Loop (Main Game Loop)
        function animate() {
            requestAnimationFrame(animate);

            const delta = clock.getDelta();

            if (isLoaded) {
                // Update Movement
                updateMovement(delta);

                // Weapon Animation (Rotation and Bobbing)
                const time = clock.getElapsedTime();
                const modelScene = models[modelNames[currentModelIndex]];
                
                // Bobbing (up/down)
                weaponGroup.position.y = Math.sin(time * 6) * 0.02;

                // Subtle Weapon Rotation (Yaw, attached to cameraPitch)
                // We rotate the model slightly within the weaponGroup, not the group itself
                modelScene.rotation.y = Math.PI / 2 + 0.1 + Math.sin(time * 1.5) * 0.01;
            }

            renderer.render(scene, camera);
        }

        // 6. Handle Window Resize
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        window.addEventListener('resize', onWindowResize);

        // Initialize Three.js and start the loop when the window loads
        window.onload = function() {
            init();
            animate();
        };

    </script>
</body>
</html>
