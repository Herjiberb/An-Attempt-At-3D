<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FPS Parkour - Infinite</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #1a1a1a; user-select: none; }
        #hud {
            position: absolute; bottom: 20px; left: 20px; width: 300px;
            font-family: 'Segoe UI', sans-serif; pointer-events: none;
        }
        .bar-container {
            width: 100%; height: 20px; background: rgba(0,0,0,0.5);
            margin-bottom: 5px; border: 2px solid #555;
        }
        #stamina-bar { width: 100%; height: 100%; background: #00ffcc; transition: width 0.1s; }
        #crosshair {
            position: absolute; top: 50%; left: 50%; width: 10px; height: 10px;
            background: white; border-radius: 50%; transform: translate(-50%, -50%);
            mix-blend-mode: difference; pointer-events: none;
        }
        #instructions {
            position: absolute; top: 20px; right: 20px; text-align: right;
            color: rgba(255, 255, 255, 0.7); font-family: monospace; pointer-events: none;
        }
        #loading {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: #00ffcc; font-family: sans-serif; font-size: 24px; font-weight: bold;
            text-shadow: 0 0 10px #00ffcc;
        }
    </style>
</head>
<body>
    <div id="crosshair"></div>
    <div id="loading">GENERATING WORLD...</div>
    
    <div id="hud">
        <div style="color:white; margin-bottom:5px;">STAMINA</div>
        <div class="bar-container"><div id="stamina-bar"></div></div>
        <div id="weapon-name" style="color:white; font-size: 14px;">FISTS</div>
    </div>

    <div id="instructions">
        WASD - Move<br>
        SHIFT - Sprint (Hold)<br>
        SPACE - Jump / Wall Jump<br>
        C - Slide / Crouch<br>
        L-CLICK - Attack<br>
        R-CLICK - Switch Weapon
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

        // --- CONFIGURATION ---
        const SEED = 888;
        const CHUNK_SIZE = 100;
        const MOVESPEED = 12;
        const SPRINT_SPEED = 22;
        const JUMP_FORCE = 18;
        const GRAVITY = 40;
        const WALL_JUMP_FORCE = 25;
        
        // --- GAME STATE ---
        const state = {
            stamina: 100,
            isSprinting: false,
            isSliding: false,
            canWallJump: false,
            onGround: false,
            velocity: new THREE.Vector3(),
            cameraHeight: 1.7
        };

        // --- SCENE SETUP ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87CEEB); // Sky
        scene.fog = new THREE.Fog(0x87CEEB, 10, 90);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true; // Shadows enabled
        document.body.appendChild(renderer.domElement);

        // Lighting
        const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 1.0);
        scene.add(hemiLight);
        const dirLight = new THREE.DirectionalLight(0xffffff, 1.0);
        dirLight.position.set(50, 100, 50);
        dirLight.castShadow = true;
        // Configure shadow properties for better quality
        dirLight.shadow.mapSize.width = 2048;
        dirLight.shadow.mapSize.height = 2048;
        dirLight.shadow.camera.near = 10;
        dirLight.shadow.camera.far = 200;
        dirLight.shadow.camera.left = -100;
        dirLight.shadow.camera.right = 100;
        dirLight.shadow.camera.top = 100;
        dirLight.shadow.camera.bottom = -100;
        scene.add(dirLight);

        // --- PLAYER CONTROLLER OBJECTS ---
        // In FPS, the "Player" is just a capsule/point. The camera sits on top.
        const playerBody = new THREE.Group();
        scene.add(playerBody);
        
        // Attach camera to player body
        playerBody.add(camera);
        camera.position.y = state.cameraHeight;

        // Weapon Holder (Attached to Camera so it moves with view)
        const handGroup = new THREE.Group();
        handGroup.position.set(0.5, -0.4, -0.8); // Bottom right of screen
        handGroup.rotation.set(0, -0.2, 0); // Slight tilt
        camera.add(handGroup);

        // --- ASSETS ---
        const loader = new GLTFLoader();
        const weapons = [];
        let currentWeaponIdx = -1;

        async function loadAssets() {
            try {
                // 1. Load Player (Invisible, just for "presence" logic if needed later)
                const playerGltf = await loader.loadAsync('./Player.glb');
                const pMesh = playerGltf.scene;
                pMesh.visible = false; // "Rendered completely out of view"
                playerBody.add(pMesh);

                // 2. Load Weapons
                const files = ['BattleAxe.glb', 'Sword.glb', 'Pickaxe.glb'];
                const names = ['Battle Axe', 'Sword', 'Pickaxe'];
                
                for(let i=0; i<files.length; i++) {
                    const gltf = await loader.loadAsync('./' + files[i]);
                    const w = gltf.scene;
                    
                    // Adjust scales/rotations to look good in First Person
                    // These numbers are tweaked for standard FPS view
                    if(names[i] === 'Sword') {
                        w.scale.set(1.5, 1.5, 1.5);
                        w.rotation.set(0, Math.PI/2, 0); 
                    } else if (names[i] === 'Battle Axe') {
                        w.scale.set(2, 2, 2);
                        w.rotation.set(0, Math.PI, 0);
                    } else {
                        w.scale.set(2, 2, 2);
                    }
                    
                    w.visible = false;
                    handGroup.add(w);
                    weapons.push({ mesh: w, name: names[i] });
                }

                if(weapons.length > 0) switchWeapon(0);
                document.getElementById('loading').style.display = 'none';

            } catch (e) {
                console.error(e);
                document.getElementById('loading').innerText = "Asset Error";
            }
        }
        loadAssets();

        function switchWeapon(idx) {
            if(weapons.length === 0) return;
            // Hide all
            weapons.forEach(w => w.mesh.visible = false);
            
            if(idx === -1) idx = 0;
            currentWeaponIdx = idx % weapons.length;
            
            weapons[currentWeaponIdx].mesh.visible = true;
            document.getElementById('weapon-name').innerText = weapons[currentWeaponIdx].name;

            // Little "equip" pop animation
            handGroup.position.y = -0.8;
        }

        // --- TERRAIN & STONEHENGE GENERATION ---
        const textureLoader = new THREE.TextureLoader();
        
        // Load and configure Stone Texture
        const stoneTexture = textureLoader.load('./Stone.jpg');
        stoneTexture.wrapS = stoneTexture.wrapT = THREE.RepeatWrapping;
        stoneTexture.repeat.set(5, 5); // Repeat 5 times
        
        // Load and configure Grass Texture
        const grassTexture = textureLoader.load('./Grass.jpg');
        grassTexture.wrapS = grassTexture.wrapT = THREE.RepeatWrapping;
        grassTexture.repeat.set(50, 50); // Repeat across large terrain

        // Material for blocks (now uses stone texture)
        const stoneMat = new THREE.MeshStandardMaterial({ map: stoneTexture, roughness: 0.7, metalness: 0.1 });
        
        // Helper noise function
        function noise(x, z) {
            return (Math.sin(x * 0.05 + SEED) + Math.cos(z * 0.05 + SEED)) * 2;
        }

        const worldGeo = new THREE.PlaneGeometry(300, 300, 100, 100);
        worldGeo.rotateX(-Math.PI/2);
        const posAttr = worldGeo.attributes.position;
        for(let i=0; i<posAttr.count; i++) {
            const x = posAttr.getX(i);
            const z = posAttr.getZ(i);
            let y = noise(x, z) * 2; // Low rolling hills
            if(y < -2) y = -2; // Water level flat
            posAttr.setY(i, y);
        }
        worldGeo.computeVertexNormals();
        
        // Terrain Material (now uses grass texture)
        const terrainMat = new THREE.MeshStandardMaterial({ map: grassTexture });
        
        const terrain = new THREE.Mesh(worldGeo, terrainMat);
        terrain.receiveShadow = true;
        scene.add(terrain);

        // Parkour Obstacles Array (for collision detection)
        const obstacles = [];

        function createBlock(x, z, w, h, d) {
            const geo = new THREE.BoxGeometry(w, h, d);
            
            // Texture mapping: scale texture repetition based on block size
            const repeatX = w / 5; 
            const repeatY = h / 5;
            const repeatZ = d / 5;
            
            const uvs = geo.attributes.uv.array;
            // Iterate over each face's UVs (8 vertices per face * 3 components = 24 total)
            for (let i = 0; i < uvs.length; i += 2) {
                // Front and Back faces (using x/y -> scale by w/h)
                if (i >= 0 && i < 8) { // Front face
                    uvs[i] *= repeatX; uvs[i+1] *= repeatY;
                } else if (i >= 8 && i < 16) { // Back face
                    uvs[i] *= repeatX; uvs[i+1] *= repeatY;
                }
                // Top and Bottom faces (using x/z -> scale by w/d)
                else if (i >= 16 && i < 24) { // Top face
                    uvs[i] *= repeatX; uvs[i+1] *= repeatZ;
                } else if (i >= 24 && i < 32) { // Bottom face
                    uvs[i] *= repeatX; uvs[i+1] *= repeatZ;
                }
                // Right and Left faces (using z/y -> scale by d/h)
                else if (i >= 32 && i < 40) { // Right face
                    uvs[i] *= repeatZ; uvs[i+1] *= repeatY;
                } else if (i >= 40 && i < 48) { // Left face
                    uvs[i] *= repeatZ; uvs[i+1] *= repeatY;
                }
            }
            geo.attributes.uv.needsUpdate = true;
            
            const mesh = new THREE.Mesh(geo, stoneMat);
            
            // Get terrain height at block center for proper placement
            const terrainBaseY = getTerrainY(x, z); 
            let y = terrainBaseY;
            
            mesh.position.set(x, y + h/2, z); // Center position is base + half height
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            scene.add(mesh);
            obstacles.push(mesh);
            
            // Add bounding box for physics
            mesh.userData.box = new THREE.Box3().setFromObject(mesh);
        }

        function generateStonehenge(cx, cz) {
            // Circle of pillars
            const radius = 15;
            const count = 8;
            for(let i=0; i<count; i++) {
                const angle = (i / count) * Math.PI * 2;
                const x = cx + Math.cos(angle) * radius;
                const z = cz + Math.sin(angle) * radius;
                
                // Tall pillar
                createBlock(x, z, 2, 8 + Math.random()*4, 2);
                
                // Lintel (connecting top) if lucky
                if(Math.random() > 0.5) {
                    const nextAngle = ((i+1) / count) * Math.PI * 2;
                    const nx = cx + Math.cos(nextAngle) * radius;
                    const nz = cz + Math.sin(nextAngle) * radius;
                    const midX = (x + nx) / 2;
                    const midZ = (z + nz) / 2;
                    
                    const blockHeight = 1;
                    const terrainBaseY = getTerrainY(midX, midZ);

                    // Create bridge geometry manually to control texture mapping for length
                    const bridgeGeo = new THREE.BoxGeometry(2, 1, 10);
                    // The long side of the bridge is the Z-axis (length 10)
                    // We need to scale the UVs for the top/bottom faces to repeat 10/5 = 2 times
                    const uvs = bridgeGeo.attributes.uv.array;
                    // Top/Bottom faces (uses X/Z)
                    for (let i = 16; i < 32; i += 2) { 
                        uvs[i] *= (2 / 5); // X scale (width)
                        uvs[i+1] *= (10 / 5); // Z scale (length)
                    }
                    // Right/Left faces (uses Z/Y)
                    for (let i = 32; i < 48; i += 2) { 
                        uvs[i] *= (10 / 5); // Z scale (length)
                        uvs[i+1] *= (1 / 5); // Y scale (height)
                    }
                    bridgeGeo.attributes.uv.needsUpdate = true;


                    const bridge = new THREE.Mesh(bridgeGeo, stoneMat);
                    bridge.position.set(midX, terrainBaseY + 10 + blockHeight/2, midZ); // Base Y + 10 + half height
                    bridge.lookAt(x, bridge.position.y, z);
                    
                    bridge.castShadow = true;
                    bridge.receiveShadow = true;
                    
                    scene.add(bridge);
                    obstacles.push(bridge);
                    bridge.userData.box = new THREE.Box3().setFromObject(bridge);
                }
            }
            
            // Center jumping block
            createBlock(cx, cz, 4, 3, 4);
        }

        // Generate a few henges
        generateStonehenge(0, -30);
        generateStonehenge(50, 50);
        generateStonehenge(-50, 40);

        // --- INPUTS ---
        const keys = { w:false, a:false, s:false, d:false, space:false, shift:false, c:false };
        
        // Pointer Lock
        document.body.addEventListener('click', (e) => {
            if(document.pointerLockElement !== document.body) {
                document.body.requestPointerLock();
            } else {
                if(e.button === 0) attack();
                if(e.button === 2) switchWeapon(currentWeaponIdx + 1);
            }
        });

        document.addEventListener('mousemove', (e) => {
            if(document.pointerLockElement === document.body) {
                playerBody.rotation.y -= e.movementX * 0.002;
                camera.rotation.x -= e.movementY * 0.002;
                camera.rotation.x = Math.max(-1.5, Math.min(1.5, camera.rotation.x));
            }
        });

        window.addEventListener('keydown', (e) => {
            const k = e.key.toLowerCase();
            if(keys.hasOwnProperty(k)) keys[k] = true;
            if(e.code === 'Space') {
                keys.space = true;
                handleJump();
            }
            if(e.shiftKey) keys.shift = true;
        });
        
        window.addEventListener('keyup', (e) => {
            const k = e.key.toLowerCase();
            if(keys.hasOwnProperty(k)) keys[k] = false;
            if(e.code === 'Space') keys.space = false;
            if(!e.shiftKey) keys.shift = false;
        });

        // --- PHYSICS & LOGIC ---
        let isAttacking = false;
        function attack() {
            if(isAttacking) return;
            isAttacking = true;
            // Procedural recoil/stab
            const startZ = handGroup.position.z;
            const startRot = handGroup.rotation.x;
            
            let t = 0;
            const anim = setInterval(() => {
                t += 0.2;
                // Stab forward and rotate down
                handGroup.position.z = startZ - Math.sin(t) * 0.5; 
                handGroup.rotation.x = startRot - Math.sin(t) * 0.5;
                
                if(t >= Math.PI) {
                    clearInterval(anim);
                    handGroup.position.z = startZ;
                    handGroup.rotation.x = startRot;
                    isAttacking = false;
                }
            }, 16);
        }

        function handleJump() {
            // Normal Jump
            if(state.onGround) {
                state.velocity.y = JUMP_FORCE;
            } 
            // Wall Jump
            else if (checkForWall()) {
                state.velocity.y = WALL_JUMP_FORCE;
                // Push back from wall (simple bounce logic)
                // In a real engine we'd use the wall normal, here we just push opposite to view
                const viewDir = new THREE.Vector3();
                camera.getWorldDirection(viewDir);
                state.velocity.x = -viewDir.x * 20;
                state.velocity.z = -viewDir.z * 20;
            }
        }

        const raycaster = new THREE.Raycaster();
        
        function checkForWall() {
            // Raycast in front of player
            const dir = new THREE.Vector3();
            camera.getWorldDirection(dir);
            raycaster.set(playerBody.position, dir);
            raycaster.far = 2.0; // Close range
            const hits = raycaster.intersectObjects(obstacles);
            return hits.length > 0;
        }

        // Modified getTerrainY to check blocks and terrain height
        function getTerrainY(x, z) {
            // Get terrain height from noise function (used to define the landscape)
            let terrainY = noise(x, z) * 2;
            if(terrainY < -2) terrainY = -2; // Water level flat
            
            // Check blocks/obstacles
            let maxY = terrainY; // Start with the landscape height
            
            // Note: This AABB check is simple and might fail for rotated/complex obstacles.
            // A more robust solution would involve raycasting down from the player.
            for(let ob of obstacles) {
                const box = ob.userData.box;
                if(x >= box.min.x && x <= box.max.x && z >= box.min.z && z <= box.max.z) {
                    if(box.max.y > maxY) maxY = box.max.y;
                }
            }
            
            return maxY;
        }

        const clock = new THREE.Clock();

        function update() {
            requestAnimationFrame(update);
            const delta = Math.min(clock.getDelta(), 0.1);

            // 1. Stamina Logic
            if(keys.shift && (keys.w || keys.a || keys.s || keys.d)) {
                state.stamina = Math.max(0, state.stamina - 30 * delta);
            } else {
                state.stamina = Math.min(100, state.stamina + 15 * delta);
            }
            document.getElementById('stamina-bar').style.width = state.stamina + '%';

            // 2. Speed Calculation
            let speed = MOVESPEED;
            if(keys.shift && state.stamina > 0) speed = SPRINT_SPEED;
            if(keys.c) { // Sliding/Crouch
                state.cameraHeight = THREE.MathUtils.lerp(state.cameraHeight, 0.8, 0.2); // Duck
                if(speed > MOVESPEED) speed += 5; // Slide boost
            } else {
                state.cameraHeight = THREE.MathUtils.lerp(state.cameraHeight, 1.7, 0.2); // Stand
            }
            // camera.position.y is updated below with a clamp

            // 3. Movement
            const forward = new THREE.Vector3(0, 0, -1).applyAxisAngle(new THREE.Vector3(0,1,0), playerBody.rotation.y);
            const right = new THREE.Vector3(1, 0, 0).applyAxisAngle(new THREE.Vector3(0,1,0), playerBody.rotation.y);
            
            const moveDir = new THREE.Vector3();
            if(keys.w) moveDir.add(forward);
            if(keys.s) moveDir.sub(forward);
            if(keys.d) moveDir.add(right);
            if(keys.a) moveDir.sub(right);
            
            if(moveDir.length() > 0) moveDir.normalize();

            // Apply inertia/slide
            state.velocity.x = THREE.MathUtils.lerp(state.velocity.x, moveDir.x * speed, keys.c ? 0.02 : 0.1);
            state.velocity.z = THREE.MathUtils.lerp(state.velocity.z, moveDir.z * speed, keys.c ? 0.02 : 0.1);

            // Gravity
            state.velocity.y -= GRAVITY * delta;

            // Apply Position
            playerBody.position.x += state.velocity.x * delta;
            playerBody.position.z += state.velocity.z * delta;
            playerBody.position.y += state.velocity.y * delta;

            // 4. Collision (Ground)
            const groundH = getTerrainY(playerBody.position.x, playerBody.position.z);
            if(playerBody.position.y < groundH) {
                playerBody.position.y = groundH;
                state.velocity.y = 0;
                state.onGround = true;
            } else {
                state.onGround = false;
            }

            // **NEW: Prevent view from sinking below ground**
            // The camera position is relative to the playerBody, so we only update the camera's Y position
            // to reflect the crouch/stand state, but we ensure it's always >= the required minimum height
            camera.position.y = Math.max(
                state.cameraHeight, // Target height (1.7 or 0.8)
                (playerBody.position.y - groundH) + 0.1 // Minimum height above ground/block collision point
            );


            // Weapon Sway (Idle)
            const time = clock.getElapsedTime();
            if(!isAttacking) {
                handGroup.position.y = -0.4 + Math.sin(time * 2) * 0.02;
                handGroup.position.x = 0.5 + Math.cos(time * 1.5) * 0.02;
            }
            // Weapon Run Sway
            if((keys.w||keys.a||keys.s||keys.d) && state.onGround) {
                handGroup.position.y += Math.sin(time * 15) * 0.05;
            }
            
            // "Lerp" weapon back to position after attack
            if(!isAttacking) {
               handGroup.rotation.x = THREE.MathUtils.lerp(handGroup.rotation.x, 0, 0.1);
               handGroup.position.z = THREE.MathUtils.lerp(handGroup.position.z, -0.8, 0.1); 
            }

            renderer.render(scene, camera);
        }

        // Handle Resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        update();
    </script>
</body>
</html>