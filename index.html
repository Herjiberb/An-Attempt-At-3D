<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3rd Person RPG - Infinite World</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #87CEEB; user-select: none; }
        #ui {
            position: absolute; top: 20px; left: 20px; color: white;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            text-shadow: 2px 2px 0 #000; pointer-events: none;
        }
        #instructions {
            position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%);
            color: rgba(255, 255, 255, 0.8); font-family: monospace; font-size: 14px;
            text-align: center; pointer-events: none;
        }
        #loading {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: white; font-family: sans-serif; font-size: 24px; font-weight: bold;
            text-shadow: 0 0 10px black; transition: opacity 0.5s;
        }
    </style>
</head>
<body>
    <div id="ui">
        <h2>Legend of the Infinite</h2>
        <div id="weapon-name">Weapon: None</div>
    </div>
    <div id="loading">Loading Assets...</div>
    <div id="instructions">
        WASD to Move • MOUSE to Look • CLICK to Lock Cursor<br>
        L-CLICK Attack • R-CLICK Switch Weapon
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';

        // --- CONFIGURATION ---
        const SEED = 12345; // Change this number to get a different world
        const RENDER_DISTANCE = 80;
        const SPEED = 10;
        const JUMP_FORCE = 15;
        
        // --- SEEDED NOISE (Simple Value Noise) ---
        // This allows the terrain to be infinite yet consistent
        function simpleHash(x, z) {
            let h = Math.sin(x * 12.9898 + z * 78.233 + SEED) * 43758.5453;
            return h - Math.floor(h);
        }
        function noise(x, z) {
            let i = Math.floor(x);
            let j = Math.floor(z);
            let u = x - i;
            let v = z - j;
            // Smoothstep
            u = u * u * (3 - 2 * u);
            v = v * v * (3 - 2 * v);
            
            // Mix
            const a = simpleHash(i, j);
            const b = simpleHash(i + 1, j);
            const c = simpleHash(i, j + 1);
            const d = simpleHash(i + 1, j + 1);
            
            return a * (1 - u) * (1 - v) + 
                   b * u * (1 - v) + 
                   c * (1 - u) * v + 
                   d * u * v;
        }
        function getTerrainHeight(x, z) {
            // Combine frequencies for "Green Hill" look
            let y = noise(x * 0.05, z * 0.05) * 10;
            y += noise(x * 0.02, z * 0.02) * 20; // Big hills
            return Math.max(y - 5, -10); // Floor
        }

        // --- SCENE SETUP ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87CEEB);
        scene.fog = new THREE.Fog(0x87CEEB, 20, RENDER_DISTANCE - 10);

        const camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, RENDER_DISTANCE);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderer.domElement);

        // --- LIGHTING ---
        const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 0.8);
        scene.add(hemiLight);

        const dirLight = new THREE.DirectionalLight(0xffffff, 1.5);
        dirLight.position.set(50, 100, 50);
        dirLight.castShadow = true;
        dirLight.shadow.camera.top = 50;
        dirLight.shadow.camera.bottom = -50;
        dirLight.shadow.camera.left = -50;
        dirLight.shadow.camera.right = 50;
        dirLight.shadow.mapSize.width = 2048;
        dirLight.shadow.mapSize.height = 2048;
        scene.add(dirLight);

        // --- INFINITE TERRAIN MESH ---
        // A rolling grid that stays under the player
        const CHUNK_SIZE = 100;
        const RES = 64;
        const geo = new THREE.PlaneGeometry(CHUNK_SIZE * 2, CHUNK_SIZE * 2, RES, RES);
        geo.rotateX(-Math.PI / 2);
        const mat = new THREE.MeshStandardMaterial({ 
            color: 0x4C9A2A, 
            roughness: 0.9,
            side: THREE.DoubleSide
        });
        const terrainMesh = new THREE.Mesh(geo, mat);
        terrainMesh.receiveShadow = true;
        scene.add(terrainMesh);

        function updateTerrain(playerPos) {
            // Snap mesh to player grid
            const snapX = Math.floor(playerPos.x);
            const snapZ = Math.floor(playerPos.z);
            terrainMesh.position.set(snapX, 0, snapZ);
            
            // Update vertices based on world position
            const posAttr = terrainMesh.geometry.attributes.position;
            for(let i=0; i < posAttr.count; i++) {
                // Local coordinate
                const lx = (i % (RES + 1)) / RES * (CHUNK_SIZE * 2) - CHUNK_SIZE;
                const lz = Math.floor(i / (RES + 1)) / RES * (CHUNK_SIZE * 2) - CHUNK_SIZE;
                
                // World coordinate
                const wx = lx + snapX;
                const wz = lz + snapZ;
                
                // Set Height
                posAttr.setY(i, getTerrainHeight(wx, wz));
            }
            posAttr.needsUpdate = true;
            terrainMesh.geometry.computeVertexNormals();
        }

        // --- PLAYER & ASSETS ---
        const playerContainer = new THREE.Group();
        scene.add(playerContainer);

        // Camera Pivot (The invisible point the camera rotates around)
        const cameraPivot = new THREE.Object3D();
        playerContainer.add(cameraPivot);
        cameraPivot.position.y = 1.5; // Look at head height
        
        // Camera Holder (For distance)
        const cameraHolder = new THREE.Object3D();
        cameraHolder.position.z = 6; // Distance behind player
        cameraPivot.add(cameraHolder);
        cameraHolder.add(camera);

        // Hand / Weapon Holder
        const handGroup = new THREE.Group();
        // Since Player.glb has no bones, we position this relative to the body roughly where a hand is
        handGroup.position.set(0.4, 1.0, 0.4); 
        playerContainer.add(handGroup);

        const loader = new GLTFLoader();
        const weapons = [];
        let currentWeaponIdx = 0;
        let enemyModel = null;

        // Asset Loader
        async function loadGameAssets() {
            try {
                // 1. Load Player
                const playerGltf = await loader.loadAsync('./Player.glb');
                const playerMesh = playerGltf.scene;
                playerMesh.traverse(c => { if(c.isMesh) c.castShadow = true; });
                // Scale player if needed (check your export, assumed 1 unit = 1 meter)
                // playerMesh.scale.set(1,1,1); 
                playerContainer.add(playerMesh);

                // 2. Load Weapons
                const weaponFiles = ['BattleAxe.glb', 'Sword.glb', 'Pickaxe.glb'];
                const weaponNames = ['Battle Axe', 'Sword', 'Pickaxe'];
                
                for(let i=0; i<weaponFiles.length; i++) {
                    const gltf = await loader.loadAsync('./' + weaponFiles[i]);
                    const wMesh = gltf.scene;
                    // Standardize weapon scale/rotation if exports are weird
                    // wMesh.scale.set(1.5, 1.5, 1.5); 
                    wMesh.visible = false;
                    handGroup.add(wMesh);
                    weapons.push({ mesh: wMesh, name: weaponNames[i] });
                }
                
                if(weapons.length > 0) {
                    weapons[0].mesh.visible = true;
                    document.getElementById('weapon-name').innerText = "Weapon: " + weapons[0].name;
                }

                // 3. Load Enemy (for scattering)
                const enemyGltf = await loader.loadAsync('./Enemy.glb');
                enemyModel = enemyGltf.scene;
                enemyModel.traverse(c => { if(c.isMesh) { c.castShadow = true; c.receiveShadow = true; }});
                
                // Spawn some enemies
                spawnEnemies();

                document.getElementById('loading').style.display = 'none';

            } catch (error) {
                console.error("Error loading assets:", error);
                document.getElementById('loading').innerText = "Error Loading Files (See Console)";
            }
        }
        loadGameAssets();

        const enemies = [];
        function spawnEnemies() {
            if(!enemyModel) return;
            // Spawn 10 enemies near start
            for(let i=0; i<10; i++) {
                const e = enemyModel.clone();
                const angle = Math.random() * Math.PI * 2;
                const dist = 10 + Math.random() * 20;
                e.position.set(Math.sin(angle)*dist, 0, Math.cos(angle)*dist);
                // Set height
                e.position.y = getTerrainHeight(e.position.x, e.position.z);
                scene.add(e);
                enemies.push(e);
            }
        }

        // --- CONTROLS ---
        // Pointer Locking for Mouse Look
        const canvas = renderer.domElement;
        canvas.addEventListener('click', () => {
            canvas.requestPointerLock();
        });

        let isLocked = false;
        document.addEventListener('pointerlockchange', () => {
            isLocked = document.pointerLockElement === canvas;
        });

        // Mouse Look Logic
        let camPitch = 0;
        document.addEventListener('mousemove', (e) => {
            if(!isLocked) return;
            // Rotate Player Container for YAW (Left/Right)
            // Ideally we rotate the cameraPivot for looking, and player for moving
            // But for standard MMO feel: Mouse X rotates player body
            playerContainer.rotation.y -= e.movementX * 0.002;
            
            // Mouse Y rotates camera pivot (Pitch)
            camPitch -= e.movementY * 0.002;
            camPitch = Math.max(-0.5, Math.min(1.0, camPitch)); // Clamp look up/down
            cameraPivot.rotation.x = camPitch;
        });

        // Keyboard
        const keys = { w:false, a:false, s:false, d:false, space:false };
        window.addEventListener('keydown', (e) => {
            const k = e.key.toLowerCase();
            if(keys.hasOwnProperty(k)) keys[k] = true;
            if(e.code === 'Space') keys.space = true;
        });
        window.addEventListener('keyup', (e) => {
            const k = e.key.toLowerCase();
            if(keys.hasOwnProperty(k)) keys[k] = false;
            if(e.code === 'Space') keys.space = false;
        });

        // Mouse Click Actions
        window.addEventListener('mousedown', (e) => {
            if(!isLocked) return;

            if(e.button === 0) { // Left Click - Attack
                performAttack();
            } else if (e.button === 2) { // Right Click - Switch Weapon
                switchWeapon();
            }
        });
        
        let isAttacking = false;
        function performAttack() {
            if(isAttacking) return;
            isAttacking = true;
            
            // Procedural Attack Animation (Swing handGroup)
            let rot = 0;
            const initialRot = handGroup.rotation.x;
            const speed = 0.2;
            
            // Simple swing down animation loop
            const attackAnim = setInterval(() => {
                rot += speed;
                handGroup.rotation.x = initialRot + Math.sin(rot) * 2; // Swing
                
                if(rot > Math.PI) {
                    clearInterval(attackAnim);
                    handGroup.rotation.x = initialRot;
                    isAttacking = false;
                }
            }, 16);
        }

        function switchWeapon() {
            if(weapons.length === 0) return;
            // Hide current
            weapons[currentWeaponIdx].mesh.visible = false;
            // Increment
            currentWeaponIdx = (currentWeaponIdx + 1) % weapons.length;
            // Show new
            weapons[currentWeaponIdx].mesh.visible = true;
            document.getElementById('weapon-name').innerText = "Weapon: " + weapons[currentWeaponIdx].name;
        }

        // --- GAME LOOP ---
        const clock = new THREE.Clock();
        const velocity = new THREE.Vector3();
        let isGrounded = false;

        function animate() {
            requestAnimationFrame(animate);
            
            const delta = Math.min(clock.getDelta(), 0.1);
            
            // 1. Terrain Update (Visual)
            // Only update every few frames or if moved significantly for performance, 
            // but here we do it every frame for smoothness on modern devices.
            updateTerrain(playerContainer.position);

            // 2. Physics & Movement
            if(isLocked) {
                const forward = new THREE.Vector3(0, 0, -1).applyAxisAngle(new THREE.Vector3(0,1,0), playerContainer.rotation.y);
                const right = new THREE.Vector3(1, 0, 0).applyAxisAngle(new THREE.Vector3(0,1,0), playerContainer.rotation.y);
                
                const moveDir = new THREE.Vector3();
                if(keys.w) moveDir.add(forward);
                if(keys.s) moveDir.sub(forward);
                if(keys.d) moveDir.add(right);
                if(keys.a) moveDir.sub(right);
                
                if(moveDir.length() > 0) moveDir.normalize();

                velocity.x = moveDir.x * SPEED;
                velocity.z = moveDir.z * SPEED;
            } else {
                velocity.x = 0;
                velocity.z = 0;
            }

            // Gravity
            velocity.y -= 30 * delta;

            // Apply Move
            playerContainer.position.x += velocity.x * delta;
            playerContainer.position.z += velocity.z * delta;
            playerContainer.position.y += velocity.y * delta;

            // Collision with Ground
            const groundHeight = getTerrainHeight(playerContainer.position.x, playerContainer.position.z);
            if(playerContainer.position.y < groundHeight) {
                playerContainer.position.y = groundHeight;
                velocity.y = 0;
                isGrounded = true;
            } else {
                isGrounded = false;
            }

            // Jump
            if(keys.space && isGrounded) {
                velocity.y = JUMP_FORCE;
            }

            // 3. Enemy Cleanup / Logic (Simple bobbing)
            enemies.forEach(e => {
                // Keep enemy on ground
                const h = getTerrainHeight(e.position.x, e.position.z);
                e.position.y = h;
                e.lookAt(playerContainer.position); // Face player
            });

            renderer.render(scene, camera);
        }

        // Handle Resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();
    </script>
</body>
</html>
