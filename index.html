<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FPS Parkour - Infinite</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #050505; user-select: none; }
        #hud {
            position: absolute; bottom: 20px; left: 20px; width: 300px;
            font-family: 'Segoe UI', sans-serif; pointer-events: none;
        }
        .bar-container {
            width: 100%; height: 20px; background: rgba(0,0,0,0.5);
            margin-bottom: 5px; border: 2px solid #555;
        }
        #stamina-bar { width: 100%; height: 100%; background: #00ffcc; transition: width 0.1s; }
        #crosshair {
            position: absolute; top: 50%; left: 50%; width: 8px; height: 8px;
            background: rgba(255, 255, 255, 0.8); border: 1px solid black; border-radius: 50%; 
            transform: translate(-50%, -50%); pointer-events: none;
        }
        #instructions {
            position: absolute; top: 20px; right: 20px; text-align: right;
            color: rgba(255, 255, 255, 0.8); font-family: monospace; pointer-events: none;
            text-shadow: 1px 1px 2px black;
        }
        #loading {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: #00ffcc; font-family: sans-serif; font-size: 24px; font-weight: bold;
            text-shadow: 0 0 10px #00ffcc;
        }
        #debug {
            position: absolute; top: 20px; left: 20px; color: yellow; font-family: monospace;
        }
    </style>
</head>
<body>
    <div id="crosshair"></div>
    <div id="loading">GENERATING WORLD...</div>
    <div id="debug"></div>
    
    <div id="hud">
        <div style="color:white; margin-bottom:5px;">STAMINA</div>
        <div class="bar-container"><div id="stamina-bar"></div></div>
        <div id="weapon-name" style="color:white; font-size: 14px;">FISTS</div>
    </div>

    <div id="instructions">
        WASD - Move<br>
        SHIFT - Sprint (Hold)<br>
        SPACE - Jump / Wall Jump<br>
        C - Slide / Crouch<br>
        L-CLICK - Attack<br>
        R-CLICK - Switch Weapon / Toggle Night
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { DecalGeometry } from 'three/addons/geometries/DecalGeometry.js';

        // --- CONFIGURATION ---
        // Random Seed for Infinite Generation
        const SEED = Math.random() * 10000;
        
        // Chunk Settings
        const CHUNK_SIZE = 60; // Size of each world tile
        const RENDER_DISTANCE = 2; // Radius of chunks to load (2 = 5x5 grid)
        
        // Physics
        const MOVESPEED = 12;
        const SPRINT_SPEED = 22;
        const JUMP_FORCE = 18;
        const WALL_JUMP_FORCE = 22;
        const GRAVITY = 45;
        const PLAYER_HEIGHT = 1.7;
        const PLAYER_RADIUS = 0.5;
        
        // Lighting
        const daySkyColor = 0x87CEEB;
        const nightSkyColor = 0x020202;
        
        let torchLight = null;
        let torchMesh = null;
        window.isNight = false;

        // --- STATE ---
        const state = {
            stamina: 100,
            velocity: new THREE.Vector3(),
            cameraHeight: 1.7,
            onGround: false,
            canWallJump: false,
            currentChunkKey: "0,0"
        };

        const activeChunks = new Map(); // Stores { group, obstacles: [] }
        let globalObstacles = []; // Flattened list for raycasting

        // --- SCENE SETUP ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(daySkyColor);
        scene.fog = new THREE.Fog(daySkyColor, 20, CHUNK_SIZE * (RENDER_DISTANCE + 0.5));

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap; // Softer shadows
        document.body.appendChild(renderer.domElement);

        // --- LIGHTING ---
        const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 0.6);
        scene.add(hemiLight);

        const dirLight = new THREE.DirectionalLight(0xffffff, 1.2);
        dirLight.position.set(50, 100, 50);
        dirLight.castShadow = true;
        dirLight.shadow.mapSize.set(2048, 2048);
        dirLight.shadow.camera.near = 10;
        dirLight.shadow.camera.far = 200;
        const d = 100;
        dirLight.shadow.camera.left = -d;
        dirLight.shadow.camera.right = d;
        dirLight.shadow.camera.top = d;
        dirLight.shadow.camera.bottom = -d;
        scene.add(dirLight);

        // Player Rig
        const playerBody = new THREE.Group();
        scene.add(playerBody);
        playerBody.add(camera);
        camera.position.y = state.cameraHeight;

        const handGroup = new THREE.Group();
        handGroup.position.set(0.5, -0.5, -0.6);
        camera.add(handGroup);

        // --- ASSETS ---
        const textureLoader = new THREE.TextureLoader();
        const stoneTexture = textureLoader.load('./Stone.jpg'); stoneTexture.wrapS = stoneTexture.wrapT = THREE.RepeatWrapping;
        const grassTexture = textureLoader.load('./Grass.jpg'); grassTexture.wrapS = grassTexture.wrapT = THREE.RepeatWrapping; grassTexture.repeat.set(10,10);
        const woodTexture = textureLoader.load('./Wood.jpg'); woodTexture.wrapS = woodTexture.wrapT = THREE.RepeatWrapping;
        const leafTexture = textureLoader.load('./Leaf.jpg'); leafTexture.wrapS = leafTexture.wrapT = THREE.RepeatWrapping; leafTexture.repeat.set(2,2);
        const brokenStoneTexture = textureLoader.load('./BrokenStone.jpg');

        const matStone = new THREE.MeshStandardMaterial({ map: stoneTexture, roughness: 0.8 });
        const matGrass = new THREE.MeshStandardMaterial({ map: grassTexture, roughness: 1.0 });
        const matWood = new THREE.MeshStandardMaterial({ map: woodTexture, roughness: 0.9 });
        const matLeaf = new THREE.MeshStandardMaterial({ map: leafTexture, alphaTest: 0.5, side: THREE.DoubleSide, transparent: true });
        const matDecal = new THREE.MeshStandardMaterial({ map: brokenStoneTexture, transparent: true, polygonOffset: true, polygonOffsetFactor: -4, depthWrite: false });

        const loader = new GLTFLoader();
        const weapons = [];
        let currentWeaponIdx = -1;

        async function loadAssets() {
            try {
                const files = ['BattleAxe.glb', 'Sword.glb', 'Pickaxe.glb', 'Torch.glb'];
                const names = ['Battle Axe', 'Sword', 'Pickaxe', 'Torch'];
                
                for(let i=0; i<files.length; i++) {
                    const gltf = await loader.loadAsync('./' + files[i]);
                    const w = gltf.scene;
                    w.traverse(c => { if(c.isMesh) c.castShadow = true; });
                    w.visible = false;
                    handGroup.add(w);
                    
                    if(names[i] === 'Torch') {
                        w.scale.set(2,2,2);
                        w.rotation.set(-0.5,0,0);
                        w.position.set(0.3, -0.2, 0);
                        // Glowing Tip
                        const tip = new THREE.Mesh(new THREE.SphereGeometry(0.1,8,8), new THREE.MeshBasicMaterial({color:0xffaa00}));
                        tip.position.set(0, 0.35, 0);
                        w.add(tip);
                        torchMesh = w;
                    } 
                    else if (names[i] === 'Battle Axe') {
                        w.scale.set(2,2,2);
                        w.rotation.set(0, Math.PI, 0); // FLIPPED 180 here to fix
                    }
                    else if (names[i] === 'Sword') {
                        w.scale.set(1.5,1.5,1.5);
                        w.rotation.set(0, Math.PI/2, 0);
                    }
                    else {
                        w.scale.set(2,2,2);
                    }
                    weapons.push({ mesh: w, name: names[i] });
                }
                switchWeapon(0);
                document.getElementById('loading').style.display = 'none';
            } catch(e) { console.error(e); }
        }
        loadAssets();

        function switchWeapon(idx) {
            if(weapons.length === 0) return;
            if(currentWeaponIdx !== -1 && weapons[currentWeaponIdx].name === 'Torch') toggleNightMode(false);
            weapons.forEach(w => w.mesh.visible = false);
            currentWeaponIdx = idx % weapons.length;
            const w = weapons[currentWeaponIdx];
            w.mesh.visible = true;
            document.getElementById('weapon-name').innerText = w.name;
            if(w.name === 'Torch') toggleNightMode(true);
        }

        function toggleNightMode(enable) {
            window.isNight = enable;
            const color = enable ? nightSkyColor : daySkyColor;
            scene.background.set(color);
            scene.fog.color.set(color);
            scene.fog.near = enable ? 5 : 20;
            scene.fog.far = enable ? 50 : CHUNK_SIZE * (RENDER_DISTANCE + 0.5);
            
            dirLight.intensity = enable ? 0.05 : 1.2;
            hemiLight.intensity = enable ? 0.1 : 0.6;

            if(enable) {
                if(!torchLight) {
                    torchLight = new THREE.PointLight(0xff6600, 50, 40, 2); // Higher intensity, physics decay
                    torchLight.castShadow = true;
                    handGroup.add(torchLight);
                    torchLight.position.set(0, 0.5, 0);
                }
                torchLight.visible = true;
            } else if (torchLight) {
                torchLight.visible = false;
            }
        }

        // --- INFINITE TERRAIN GENERATION ---

        function pseudoRandom(x, z) {
            let s = Math.sin(x * 12.9898 + z * 78.233 + SEED) * 43758.5453;
            return s - Math.floor(s);
        }

        function getNoise(x, z, scale = 1) {
            return (Math.sin(x * 0.04 * scale + SEED) + Math.cos(z * 0.04 * scale + SEED));
        }

        function getTerrainY(x, z) {
            // Base rolling hills
            let y = getNoise(x, z, 1.0) * 2; 
            // Add detail noise
            y += getNoise(x + 100, z + 100, 2.5) * 0.5;
            // Flatten bottom
            return Math.max(-2, y);
        }

        // --- TREE & OBSTACLE GENERATORS ---

        function createTree(group, obstacles, x, z, isMother) {
            const y = getTerrainY(x, z);
            const scale = isMother ? 2.5 + Math.random() : 1.0 + Math.random() * 0.5;
            
            // Trunk
            const h = isMother ? 12 : 5;
            const r = isMother ? 1.5 : 0.4;
            const trunkGeo = new THREE.CylinderGeometry(r * 0.7, r, h, 7);
            const trunk = new THREE.Mesh(trunkGeo, matWood);
            trunk.position.set(x, y + h/2, z);
            trunk.castShadow = true; trunk.receiveShadow = true;
            group.add(trunk);
            obstacles.push(trunk);

            // Branches
            if (isMother) {
                const branchCount = 5 + Math.floor(Math.random() * 3);
                for(let i=0; i<branchCount; i++) {
                    const branchH = 4 + Math.random() * 4;
                    const bGeo = new THREE.CylinderGeometry(0.5, 0.8, branchH, 5);
                    const branch = new THREE.Mesh(bGeo, matWood);
                    
                    // Position branch up the trunk
                    const hPos = (h * 0.4) + Math.random() * (h * 0.4);
                    branch.position.set(0, hPos - (h/2), 0);
                    
                    // Rotate out
                    branch.rotation.z = (Math.PI / 3) + (Math.random() * 0.5);
                    branch.rotation.y = Math.random() * Math.PI * 2;
                    
                    // Since rotation applies to geometry, we need to group or offset carefully.
                    // Easiest: Add to trunk, but requires complex collision logic.
                    // Better: Compute world pos.
                    
                    const container = new THREE.Object3D();
                    container.position.set(x, y + h/2, z); // Center of trunk
                    container.rotation.y = Math.random() * Math.PI * 2;
                    
                    // Offset mesh within container so pivot is at base
                    branch.position.set(branchH/2 * 0.8, hPos - (h/2) + (branchH/2 * 0.6), 0);
                    branch.rotation.z = -Math.PI / 3;
                    
                    container.add(branch);
                    group.add(container);
                    
                    // We need collision on branches! 
                    // Note: Raycasting against rotated children works automatically in Three.js
                    obstacles.push(branch);

                    // Leaves on branches
                    addLeafBlob(group, obstacles, x + Math.cos(container.rotation.y)*4, y + hPos + 2, z + Math.sin(container.rotation.y)*4, scale);
                }
            }

            // Main Leaf Top
            addLeafBlob(group, obstacles, x, y + h, z, scale);
        }

        function addLeafBlob(group, obstacles, x, y, z, scale) {
            const count = 3;
            for(let i=0; i<count; i++) {
                const geo = new THREE.IcosahedronGeometry((1.5 + Math.random()) * scale, 0);
                const mesh = new THREE.Mesh(geo, matLeaf);
                mesh.position.set(x + (Math.random()-0.5)*2, y + Math.random()*2, z + (Math.random()-0.5)*2);
                mesh.castShadow = true;
                group.add(mesh);
                obstacles.push(mesh); // Can stand on leaves
            }
        }

        function generateChunk(cx, cz) {
            const group = new THREE.Group();
            const chunkObstacles = [];
            
            // 1. Terrain Mesh
            const geo = new THREE.PlaneGeometry(CHUNK_SIZE, CHUNK_SIZE, 30, 30);
            geo.rotateX(-Math.PI/2);
            const pos = geo.attributes.position;
            for(let i=0; i<pos.count; i++) {
                const vx = pos.getX(i) + cx * CHUNK_SIZE;
                const vz = pos.getZ(i) + cz * CHUNK_SIZE;
                pos.setY(i, getTerrainY(vx, vz));
            }
            geo.computeVertexNormals();
            const mesh = new THREE.Mesh(geo, matGrass);
            mesh.position.set(cx * CHUNK_SIZE, 0, cz * CHUNK_SIZE);
            mesh.receiveShadow = true;
            group.add(mesh);

            // 2. Objects (Trees & Stones)
            // Deterministic random for this chunk
            const startX = cx * CHUNK_SIZE - CHUNK_SIZE/2;
            const startZ = cz * CHUNK_SIZE - CHUNK_SIZE/2;
            const endX = startX + CHUNK_SIZE;
            const endZ = startZ + CHUNK_SIZE;

            for(let x = startX; x < endX; x+=5) {
                for(let z = startZ; z < endZ; z+=5) {
                    const rnd = pseudoRandom(x, z);
                    const bioNoise = getNoise(x, z, 0.5); // Biome noise
                    
                    // Trees (Groves)
                    if (bioNoise > 0.8 && rnd > 0.6) {
                        const isMother = rnd > 0.95; // Rare Mother Tree
                        createTree(group, chunkObstacles, x, z, isMother);
                    }
                    // Stonehenge / Ruins
                    else if (bioNoise < -1.0 && rnd > 0.92) {
                        const h = 2 + rnd * 6;
                        const stone = new THREE.Mesh(new THREE.BoxGeometry(2, h, 2), matStone);
                        stone.position.set(x, getTerrainY(x,z) + h/2, z);
                        stone.rotation.y = rnd * Math.PI;
                        stone.rotation.z = (rnd - 0.5) * 0.5; // Slight tilt
                        stone.castShadow = true; stone.receiveShadow = true;
                        group.add(stone);
                        chunkObstacles.push(stone);
                        
                        // Bridge (Lintel)
                        if (rnd > 0.96) {
                            const bridge = new THREE.Mesh(new THREE.BoxGeometry(2, 1, 6), matStone);
                            bridge.position.set(x, getTerrainY(x,z) + h + 0.5, z + 2);
                            bridge.receiveShadow = true;
                            group.add(bridge);
                            chunkObstacles.push(bridge);
                        }
                    }
                }
            }

            scene.add(group);
            return { group, obstacles: chunkObstacles };
        }

        function updateChunks() {
            const cx = Math.round(playerBody.position.x / CHUNK_SIZE);
            const cz = Math.round(playerBody.position.z / CHUNK_SIZE);
            const currentKey = `${cx},${cz}`;
            
            if (state.currentChunkKey === currentKey && activeChunks.size > 0) return;
            state.currentChunkKey = currentKey;

            const neededKeys = new Set();
            for(let x = -RENDER_DISTANCE; x <= RENDER_DISTANCE; x++) {
                for(let z = -RENDER_DISTANCE; z <= RENDER_DISTANCE; z++) {
                    neededKeys.add(`${cx+x},${cz+z}`);
                }
            }

            // Remove old
            for(const [key, chunk] of activeChunks) {
                if(!neededKeys.has(key)) {
                    scene.remove(chunk.group);
                    // Dispose geometries to save memory
                    chunk.group.traverse(o => { if(o.geometry) o.geometry.dispose(); });
                    activeChunks.delete(key);
                }
            }

            // Add new
            for(const key of neededKeys) {
                if(!activeChunks.has(key)) {
                    const [kx, kz] = key.split(',').map(Number);
                    activeChunks.set(key, generateChunk(kx, kz));
                }
            }

            // Rebuild Global Obstacles for Raycasting
            globalObstacles = [];
            for(const chunk of activeChunks.values()) {
                globalObstacles.push(...chunk.obstacles);
            }
        }

        // --- INPUT ---
        const keys = { w:false, a:false, s:false, d:false, space:false, shift:false, c:false };
        
        document.body.addEventListener('click', (e) => {
            if(document.pointerLockElement !== document.body) document.body.requestPointerLock();
            else {
                if(e.button === 0) attack();
                if(e.button === 2) switchWeapon(currentWeaponIdx + 1);
            }
        });
        document.addEventListener('mousemove', (e) => {
            if(document.pointerLockElement === document.body) {
                playerBody.rotation.y -= e.movementX * 0.002;
                camera.rotation.x -= e.movementY * 0.002;
                camera.rotation.x = Math.max(-1.5, Math.min(1.5, camera.rotation.x));
            }
        });
        window.addEventListener('keydown', (e) => {
            if(keys.hasOwnProperty(e.key.toLowerCase())) keys[e.key.toLowerCase()] = true;
            if(e.code === 'Space') { keys.space = true; onJumpPress(); }
            if(e.shiftKey) keys.shift = true;
        });
        window.addEventListener('keyup', (e) => {
            if(keys.hasOwnProperty(e.key.toLowerCase())) keys[e.key.toLowerCase()] = false;
            if(e.code === 'Space') keys.space = false;
            if(!e.shiftKey) keys.shift = false;
        });

        // --- PHYSICS ENGINE ---
        const raycaster = new THREE.Raycaster();
        const groundRay = new THREE.Raycaster();
        
        function getGroundHeight(pos) {
            groundRay.set(new THREE.Vector3(pos.x, pos.y + 1, pos.z), new THREE.Vector3(0,-1,0));
            groundRay.far = 5;
            const hits = groundRay.intersectObjects(globalObstacles);
            const terrainY = getTerrainY(pos.x, pos.z);
            let obstacleY = -999;
            if (hits.length > 0) obstacleY = hits[0].point.y;
            return Math.max(terrainY, obstacleY);
        }

        function checkWall(pos, dir) {
            raycaster.set(pos, dir);
            raycaster.far = 1.0;
            return raycaster.intersectObjects(globalObstacles).length > 0;
        }

        function onJumpPress() {
            if(state.onGround) {
                state.velocity.y = JUMP_FORCE;
            } else if (state.canWallJump) {
                state.velocity.y = WALL_JUMP_FORCE;
                // Launch opposite to view
                const view = new THREE.Vector3();
                camera.getWorldDirection(view);
                state.velocity.x = -view.x * 15;
                state.velocity.z = -view.z * 15;
            }
        }

        // --- GAME LOOP ---
        const clock = new THREE.Clock();

        function update() {
            requestAnimationFrame(update);
            const delta = Math.min(clock.getDelta(), 0.1);
            const time = clock.getElapsedTime();

            // 1. Chunk Management
            updateChunks();

            // 2. Physics & Movement
            if(keys.shift) state.stamina = Math.max(0, state.stamina - 30*delta);
            else state.stamina = Math.min(100, state.stamina + 15*delta);
            document.getElementById('stamina-bar').style.width = state.stamina + '%';

            let speed = (keys.shift && state.stamina>0) ? SPRINT_SPEED : MOVESPEED;
            if(keys.c) { state.cameraHeight = THREE.MathUtils.lerp(state.cameraHeight, 0.8, 0.2); }
            else { state.cameraHeight = THREE.MathUtils.lerp(state.cameraHeight, PLAYER_HEIGHT, 0.2); }
            camera.position.y = state.cameraHeight;

            // Input Direction
            const fwd = new THREE.Vector3(0,0,-1).applyAxisAngle(new THREE.Vector3(0,1,0), playerBody.rotation.y);
            const rgt = new THREE.Vector3(1,0,0).applyAxisAngle(new THREE.Vector3(0,1,0), playerBody.rotation.y);
            const move = new THREE.Vector3();
            if(keys.w) move.add(fwd);
            if(keys.s) move.sub(fwd);
            if(keys.d) move.add(rgt);
            if(keys.a) move.sub(rgt);
            if(move.length()>0) move.normalize();

            // Apply Horizontal Velocity (with air control dampening)
            const factor = state.onGround ? 0.2 : 0.05;
            state.velocity.x = THREE.MathUtils.lerp(state.velocity.x, move.x * speed, factor);
            state.velocity.z = THREE.MathUtils.lerp(state.velocity.z, move.z * speed, factor);
            state.velocity.y -= GRAVITY * delta;

            // --- Collision Step (Horizontal) ---
            const nextX = playerBody.position.x + state.velocity.x * delta;
            const nextZ = playerBody.position.z + state.velocity.z * delta;
            
            // Check Wall Collisions (Waist Level)
            const waistPos = playerBody.position.clone(); 
            waistPos.y -= 0.5; // Lower slightly
            
            // Look forward to detect wall jump opportunities
            const lookDir = new THREE.Vector3();
            camera.getWorldDirection(lookDir);
            state.canWallJump = !state.onGround && checkWall(waistPos, lookDir);

            // Simple Circle Collision preventer
            // In a real engine, we'd sweep a capsule. Here, we raycast in move dir.
            if(move.length() > 0) {
                if(checkWall(waistPos, move)) {
                    state.velocity.x *= 0.1;
                    state.velocity.z *= 0.1;
                    // Slide
                }
            }

            playerBody.position.x += state.velocity.x * delta;
            playerBody.position.z += state.velocity.z * delta;
            playerBody.position.y += state.velocity.y * delta;

            // --- Collision Step (Vertical) ---
            const groundY = getGroundHeight(playerBody.position);
            if(playerBody.position.y < groundY + PLAYER_HEIGHT) {
                playerBody.position.y = groundY + PLAYER_HEIGHT;
                state.velocity.y = 0;
                state.onGround = true;
                state.canWallJump = false;
            } else {
                state.onGround = false;
            }

            // 3. Animation / Visuals
            // Sway
            const swayMag = (keys.w||keys.a||keys.s||keys.d) && state.onGround ? 0.05 : 0.002;
            const swayFreq = 10;
            handGroup.position.y = THREE.MathUtils.lerp(handGroup.position.y, -0.5 + Math.sin(time*swayFreq)*swayMag, 0.1);
            handGroup.position.x = THREE.MathUtils.lerp(handGroup.position.x, 0.5 + Math.cos(time*swayFreq)*swayMag * 0.5, 0.1);
            
            // Torch Lag
            if(window.isNight && torchLight) {
                torchLight.intensity = 40 + Math.sin(time * 20) * 5 + Math.random() * 5;
            }

            renderer.render(scene, camera);
        }

        // --- ATTACK ---
        function attack() {
            if(window.isNight) return;
            
            // Animation
            const anim = setInterval(() => {
                handGroup.rotation.x -= 0.2;
                if(handGroup.rotation.x < -1.5) {
                    clearInterval(anim);
                    const ret = setInterval(() => {
                        handGroup.rotation.x += 0.2;
                        if(handGroup.rotation.x >= 0) {
                            handGroup.rotation.x = 0;
                            clearInterval(ret);
                        }
                    }, 16);
                }
            }, 16);

            // Hitscan
            raycaster.setFromCamera(new THREE.Vector2(0,0), camera);
            raycaster.far = 4;
            const hits = raycaster.intersectObjects(globalObstacles);
            if(hits.length > 0) {
                const hit = hits[0];
                const decal = new THREE.Mesh(
                    new DecalGeometry(hit.object, hit.point, new THREE.Euler().setFromVector3(hit.face.normal), new THREE.Vector3(0.5,0.5,0.5)),
                    matDecal
                );
                scene.add(decal);
                setTimeout(() => { scene.remove(decal); decal.geometry.dispose(); }, 10000);
            }
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        update();
    </script>
</body>
</html>