<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FPS Parkour - Infinite</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #1a1a1a; user-select: none; }
        #hud {
            position: absolute; bottom: 20px; left: 20px; width: 300px;
            font-family: 'Segoe UI', sans-serif; pointer-events: none;
        }
        .bar-container {
            width: 100%; height: 20px; background: rgba(0,0,0,0.5);
            margin-bottom: 5px; border: 2px solid #555;
        }
        #stamina-bar { width: 100%; height: 100%; background: #00ffcc; transition: width 0.1s; }
        #crosshair {
            position: absolute; top: 50%; left: 50%; width: 10px; height: 10px;
            background: white; border-radius: 50%; transform: translate(-50%, -50%);
            mix-blend-mode: difference; pointer-events: none;
        }
        #instructions {
            position: absolute; top: 20px; right: 20px; text-align: right;
            color: rgba(255, 255, 255, 0.7); font-family: monospace; pointer-events: none;
        }
        #loading {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: #00ffcc; font-family: sans-serif; font-size: 24px; font-weight: bold;
            text-shadow: 0 0 10px #00ffcc;
        }
    </style>
</head>
<body>
    <div id="crosshair"></div>
    <div id="loading">GENERATING WORLD...</div>
    
    <div id="hud">
        <div style="color:white; margin-bottom:5px;">STAMINA</div>
        <div class="bar-container"><div id="stamina-bar"></div></div>
        <div id="weapon-name" style="color:white; font-size: 14px;">FISTS</div>
    </div>

    <div id="instructions">
        WASD - Move<br>
        SHIFT - Sprint (Hold)<br>
        SPACE - Jump / Wall Jump<br>
        C - Slide / Crouch<br>
        L-CLICK - Attack/Mark Stone<br>
        R-CLICK - Switch Weapon / Toggle Night
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { DecalGeometry } from 'three/addons/geometries/DecalGeometry.js';

        // --- CONFIGURATION ---
        const SEED = Math.random() * 10000; // Randomized Seed
        console.log("World Seed:", SEED);

        const MOVESPEED = 12;
        const SPRINT_SPEED = 22;
        const JUMP_FORCE = 18;
        const GRAVITY = 40;
        const WALL_JUMP_FORCE = 25;
        const PLAYER_HEIGHT = 1.7; 
        const PLAYER_RADIUS = 0.5; 
        const DECAL_FADE_TIME = 15000;
        
        // --- NIGHT MODE CONFIG ---
        const daySkyColor = 0x87CEEB;
        const nightSkyColor = 0x050505;
        const dayDirLightIntensity = 1.0;
        const nightDirLightIntensity = 0.05; 
        const TORCH_LIGHT_INTENSITY = 15;
        const TORCH_LIGHT_DISTANCE = 40;
        
        let torchLight = null;
        let torchMesh = null;
        let torchTip = null; // The glowing visible ember
        window.isNight = false;

        // --- GAME STATE ---
        const state = {
            stamina: 100,
            isSprinting: false,
            velocity: new THREE.Vector3(),
            cameraHeight: 1.7,
            onGround: false
        };

        // --- SCENE SETUP ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(daySkyColor);
        scene.fog = new THREE.Fog(daySkyColor, 10, 90);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderer.domElement);

        // Lighting
        const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 1.0);
        scene.add(hemiLight);
        const dirLight = new THREE.DirectionalLight(0xffffff, dayDirLightIntensity);
        dirLight.position.set(50, 100, 50);
        dirLight.castShadow = true;
        // High quality shadows
        dirLight.shadow.mapSize.width = 4096; 
        dirLight.shadow.mapSize.height = 4096;
        dirLight.shadow.camera.near = 10;
        dirLight.shadow.camera.far = 300;
        dirLight.shadow.camera.left = -100;
        dirLight.shadow.camera.right = 100;
        dirLight.shadow.camera.top = 100;
        dirLight.shadow.camera.bottom = -100;
        scene.add(dirLight);

        // --- PLAYER CONTROLLER OBJECTS ---
        const playerBody = new THREE.Group();
        scene.add(playerBody);
        
        playerBody.add(camera);
        camera.position.y = state.cameraHeight;

        // Weapon/Hand Holder 
        const handGroup = new THREE.Group();
        // Positioned slightly lower and forward
        handGroup.position.set(0.5, -0.5, -0.6); 
        camera.add(handGroup);

        // --- TEXTURES ---
        const textureLoader = new THREE.TextureLoader();
        
        const stoneTexture = textureLoader.load('./Stone.jpg');
        stoneTexture.wrapS = stoneTexture.wrapT = THREE.RepeatWrapping;
        stoneTexture.repeat.set(2, 2);

        const grassTexture = textureLoader.load('./Grass.jpg');
        grassTexture.wrapS = grassTexture.wrapT = THREE.RepeatWrapping;
        grassTexture.repeat.set(50, 50);

        const mudTexture = textureLoader.load('./Mud.jpg');
        const brokenStoneTexture = textureLoader.load('./BrokenStone.jpg');
        
        // New Tree Textures
        const woodTexture = textureLoader.load('./Wood.jpg');
        woodTexture.wrapS = woodTexture.wrapT = THREE.RepeatWrapping;
        
        const leafTexture = textureLoader.load('./Leaf.jpg');
        leafTexture.wrapS = leafTexture.wrapT = THREE.RepeatWrapping;
        leafTexture.repeat.set(2,2);

        // Materials
        const stoneMat = new THREE.MeshStandardMaterial({ map: stoneTexture, roughness: 0.8 });
        const terrainMat = new THREE.MeshStandardMaterial({ map: grassTexture, roughness: 1.0 });
        const mudMat = new THREE.MeshStandardMaterial({ map: mudTexture, transparent:true, opacity:0.9, roughness:0.4 });
        
        const woodMat = new THREE.MeshStandardMaterial({ map: woodTexture, roughness: 0.9 });
        const leafMat = new THREE.MeshStandardMaterial({ 
            map: leafTexture, 
            roughness: 0.8, 
            side: THREE.DoubleSide,
            alphaTest: 0.5, // Cutout transparency for leaves
            transparent: true
        });

        const decalMat = new THREE.MeshStandardMaterial({
            map: brokenStoneTexture,
            transparent: true,
            depthTest: true,
            depthWrite: false,
            polygonOffset: true,
            polygonOffsetFactor: -4, 
            roughness: 0.9
        });

        // --- ASSETS & WEAPONS ---
        const loader = new GLTFLoader();
        const weapons = [];
        let currentWeaponIdx = -1;

        function toggleNightMode(isNight) {
            window.isNight = isNight;
            
            const targetColor = isNight ? nightSkyColor : daySkyColor;
            dirLight.intensity = isNight ? nightDirLightIntensity : dayDirLightIntensity;

            scene.background.set(targetColor);
            scene.fog.color.set(targetColor);
            scene.fog.near = isNight ? 1 : 10;
            scene.fog.far = isNight ? 40 : 90;

            if (isNight) {
                if (!torchLight) {
                    // Warm, orange/red light
                    torchLight = new THREE.PointLight(0xff6600, TORCH_LIGHT_INTENSITY, TORCH_LIGHT_DISTANCE, 1.5);
                    torchLight.castShadow = true;
                    torchLight.shadow.bias = -0.0001;
                    
                    // Attach physics light to the torch mesh directly if possible, or camera
                    // Attaching to handGroup ensures it sways with the weapon
                    handGroup.add(torchLight); 
                    torchLight.position.set(0, 0.5, 0); // Offset to be near the tip
                }
                torchLight.visible = true;
            } else {
                if (torchLight) torchLight.visible = false;
            }
        }

        async function loadAssets() {
            try {
                // Load Weapons
                const files = ['BattleAxe.glb', 'Sword.glb', 'Pickaxe.glb', 'Torch.glb'];
                const names = ['Battle Axe', 'Sword', 'Pickaxe', 'Torch'];
                
                for(let i=0; i<files.length; i++) {
                    const gltf = await loader.loadAsync('./' + files[i]);
                    const w = gltf.scene;
                    
                    w.traverse(child => { if(child.isMesh) child.castShadow = true; });
                    
                    w.visible = false;
                    handGroup.add(w);
                    
                    if(names[i] === 'Torch') {
                        // Torch specific Setup
                        w.scale.set(2.0, 2.0, 2.0);
                        w.rotation.set(-0.5, 0, 0); // Point forward
                        w.position.set(0.3, -0.2, 0); // Make it more visible on right
                        
                        // Add Glowing Tip visual
                        const tipGeo = new THREE.SphereGeometry(0.08, 8, 8);
                        const tipMat = new THREE.MeshBasicMaterial({ color: 0xffaa00 });
                        torchTip = new THREE.Mesh(tipGeo, tipMat);
                        // Approximate tip position based on typical torch models
                        torchTip.position.set(0, 0.35, 0); 
                        w.add(torchTip);
                        
                        torchMesh = w;
                    } else if (names[i] === 'Sword') {
                        w.scale.set(1.5, 1.5, 1.5);
                        w.rotation.set(0, Math.PI/2, 0);
                    } else {
                        w.scale.set(2, 2, 2);
                    }

                    weapons.push({ mesh: w, name: names[i] });
                }

                if(weapons.length > 0) switchWeapon(0);
                document.getElementById('loading').style.display = 'none';

            } catch (e) {
                console.error("Asset load error:", e);
                document.getElementById('loading').innerText = "Asset Error (Check Console)";
            }
        }
        loadAssets();

        function switchWeapon(idx) {
            if(weapons.length === 0) return;
            if (currentWeaponIdx !== -1 && weapons[currentWeaponIdx].name === 'Torch') toggleNightMode(false);

            weapons.forEach(w => w.mesh.visible = false);
            
            if(idx === -1) idx = 0;
            currentWeaponIdx = idx % weapons.length;
            
            const newWeapon = weapons[currentWeaponIdx];
            newWeapon.mesh.visible = true;
            document.getElementById('weapon-name').innerText = newWeapon.name;
            
            if (newWeapon.name === 'Torch') {
                toggleNightMode(true);
            }
        }

        // --- WORLD GENERATION ---
        
        // Obstacles array for collision
        const obstacles = [];

        function noise(x, z) {
            return (Math.sin(x * 0.04 + SEED) + Math.cos(z * 0.04 + SEED)) * 2;
        }

        function getRawTerrainY(x, z) {
            let y = noise(x, z) * 2.5;
            if(y < -2) y = -2;
            return y;
        }

        // Generate Ground Plane
        const worldGeo = new THREE.PlaneGeometry(300, 300, 120, 120);
        worldGeo.rotateX(-Math.PI/2);
        const posAttr = worldGeo.attributes.position;
        for(let i=0; i<posAttr.count; i++) {
            const x = posAttr.getX(i);
            const z = posAttr.getZ(i);
            posAttr.setY(i, getRawTerrainY(x, z));
        }
        worldGeo.computeVertexNormals();
        const terrain = new THREE.Mesh(worldGeo, terrainMat);
        terrain.receiveShadow = true;
        scene.add(terrain);
        // Terrain is not in obstacles array because we handle it via fallback in getGroundHeight

        // Helper: Create Stone Block
        function createBlock(x, z, w, h, d, yOffset = 0, rotationY = 0) {
            const geo = new THREE.BoxGeometry(w, h, d);
            const mesh = new THREE.Mesh(geo, stoneMat.clone());
            
            const terrainY = getRawTerrainY(x, z);
            mesh.position.set(x, terrainY + h/2 + yOffset, z);
            mesh.rotation.y = rotationY;
            
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            scene.add(mesh);
            obstacles.push(mesh); // Raycaster will hit this
            return mesh;
        }

        function generateStonehenge(cx, cz) {
            const radius = 12 + Math.random() * 5;
            const count = 6 + Math.floor(Math.random() * 4);
            
            for(let i=0; i<count; i++) {
                const angle = (i / count) * Math.PI * 2;
                const x = cx + Math.cos(angle) * radius;
                const z = cz + Math.sin(angle) * radius;
                
                // Pillar
                createBlock(x, z, 2.5, 7 + Math.random()*3, 2.5);

                // Horizontal Lintel (Bridge)
                // 50% chance to connect to next pillar
                if(Math.random() > 0.3) {
                    const nextAngle = ((i+1) / count) * Math.PI * 2;
                    const nx = cx + Math.cos(nextAngle) * radius;
                    const nz = cz + Math.sin(nextAngle) * radius;
                    
                    const midX = (x + nx) / 2;
                    const midZ = (z + nz) / 2;
                    const dist = Math.sqrt(Math.pow(nx-x, 2) + Math.pow(nz-z, 2));
                    
                    const height = 9; 
                    const bridge = createBlock(midX, midZ, 2.5, 1.5, dist + 2, height - (1.5/2));
                    
                    // Rotate bridge to face next pillar
                    // Important: LookAt works, and Raycaster will solve the collision
                    bridge.lookAt(x, bridge.position.y, z);
                }
            }
            // Altar
            createBlock(cx, cz, 5, 2, 3);
        }

        // Tree Generation
        function createTree(x, z) {
            const scale = 1 + Math.random();
            const trunkH = 4 * scale;
            const terrainY = getRawTerrainY(x, z);
            
            // Trunk
            const trunkGeo = new THREE.CylinderGeometry(0.4 * scale, 0.6 * scale, trunkH, 8);
            const trunk = new THREE.Mesh(trunkGeo, woodMat);
            trunk.position.set(x, terrainY + trunkH/2, z);
            trunk.castShadow = true;
            trunk.receiveShadow = true;
            scene.add(trunk);
            obstacles.push(trunk);

            // Leaves (Bushy/Bumpy)
            const leafGroup = new THREE.Group();
            const leafCount = 4 + Math.floor(Math.random() * 3);
            
            for(let i=0; i<leafCount; i++) {
                const size = (1.5 + Math.random()) * scale;
                // Icosahedron looks bumpier than sphere
                const geo = new THREE.IcosahedronGeometry(size, 0); 
                const mesh = new THREE.Mesh(geo, leafMat);
                
                // Random offset from top of trunk
                mesh.position.set(
                    (Math.random() - 0.5) * 2 * scale,
                    (Math.random() * 2) * scale,
                    (Math.random() - 0.5) * 2 * scale
                );
                leafGroup.add(mesh);
            }
            leafGroup.position.set(x, terrainY + trunkH, z);
            scene.add(leafGroup);
            
            // Add leaves to obstacles so we can jump on them!
            leafGroup.traverse(c => {
                if(c.isMesh) {
                    c.castShadow = true;
                    obstacles.push(c);
                }
            });
        }

        function generateGroves() {
            // Use a secondary noise function for biome/grove placement
            for(let x = -140; x < 140; x+=5) {
                for(let z = -140; z < 140; z+=5) {
                    // Low frequency noise for "forest zones"
                    const zone = Math.sin(x * 0.02 + SEED) * Math.cos(z * 0.02 + SEED * 2);
                    
                    if (zone > 0.6) { // Only place trees in "high" zones (Groves)
                        // Add randomness within the grid cell
                        if(Math.random() > 0.4) { 
                            const jx = x + (Math.random()-0.5)*4;
                            const jz = z + (Math.random()-0.5)*4;
                            createTree(jx, jz);
                        }
                    }
                }
            }
        }

        // Build World
        generateStonehenge(0, -30);
        generateStonehenge(60, 60);
        generateStonehenge(-60, 50);
        generateGroves();

        // Mud Puddles
        for(let i=0; i<20; i++) {
            const px = (Math.random()-0.5)*200;
            const pz = (Math.random()-0.5)*200;
            const pGeo = new THREE.CircleGeometry(4, 16);
            pGeo.rotateX(-Math.PI/2);
            const pMesh = new THREE.Mesh(pGeo, mudMat);
            const py = getRawTerrainY(px, pz);
            pMesh.position.set(px, py + 0.05, pz);
            scene.add(pMesh);
        }


        // --- INPUT & PHYSICS ---
        const keys = { w:false, a:false, s:false, d:false, space:false, shift:false, c:false };
        
        document.body.addEventListener('click', (e) => {
            if(document.pointerLockElement !== document.body) {
                document.body.requestPointerLock();
            } else {
                if(e.button === 0) attack();
                if(e.button === 2) switchWeapon(currentWeaponIdx + 1);
            }
        });

        document.addEventListener('mousemove', (e) => {
            if(document.pointerLockElement === document.body) {
                playerBody.rotation.y -= e.movementX * 0.002;
                camera.rotation.x -= e.movementY * 0.002;
                camera.rotation.x = Math.max(-1.5, Math.min(1.5, camera.rotation.x));
                
                // Add sway to weapon based on mouse input
                if (!isAttacking) {
                    const swayX = -e.movementX * 0.0005;
                    const swayY = -e.movementY * 0.0005;
                    handGroup.position.x += swayX;
                    handGroup.position.y += swayY;
                }
            }
        });

        window.addEventListener('keydown', (e) => {
            const k = e.key.toLowerCase();
            if(keys.hasOwnProperty(k)) keys[k] = true;
            if(e.code === 'Space') { keys.space = true; handleJump(); }
            if(e.shiftKey) keys.shift = true;
        });
        window.addEventListener('keyup', (e) => {
            const k = e.key.toLowerCase();
            if(keys.hasOwnProperty(k)) keys[k] = false;
            if(e.code === 'Space') keys.space = false;
            if(!e.shiftKey) keys.shift = false;
        });

        // --- NEW PHYSICS SYSTEM (RAYCASTING) ---
        const downRay = new THREE.Raycaster();
        const wallRay = new THREE.Raycaster();
        const attackRay = new THREE.Raycaster();

        // 1. Precise Ground Detection
        function getGroundHeight(pos) {
            // Raycast down from slightly above the player's feet
            const origin = new THREE.Vector3(pos.x, pos.y + 0.5, pos.z);
            downRay.set(origin, new THREE.Vector3(0, -1, 0));
            downRay.far = 10; // Don't check too far down

            // Intersect with all obstacles
            const hits = downRay.intersectObjects(obstacles);
            
            let obstacleY = -999;
            if(hits.length > 0) {
                // The hit point is the exact surface height of the rotated mesh
                obstacleY = hits[0].point.y;
            }

            // Also check Terrain math
            const terrainY = getRawTerrainY(pos.x, pos.z);

            return Math.max(obstacleY, terrainY);
        }

        // 2. Wall Detection for Wall Jump
        function checkForWall() {
            const dir = new THREE.Vector3();
            camera.getWorldDirection(dir);
            wallRay.set(playerBody.position, dir);
            wallRay.far = 1.5;
            return wallRay.intersectObjects(obstacles).length > 0;
        }

        // 3. Horizontal Collision (Simple push-back)
        function checkCollisions(pos) {
            // Simple proximity check for horizontal walls to prevent walking through
            // We use a simplified box approach for horizontal to keep it fast, 
            // but we rely on raycasting for vertical standing.
            for (let ob of obstacles) {
                // Get world position of obstacle
                // Calculate distance
                const dist = pos.distanceTo(ob.position);
                // Crude approximation for simplicity in this specific demo
                // Ideally we'd use a capsule collider or multiple rays
                if (dist < 2.0) {
                    // If too close and at same height range
                    if (pos.y > ob.position.y - 2 && pos.y < ob.position.y + 2) {
                        // Very basic push out
                        const dir = new THREE.Vector3().subVectors(pos, ob.position).normalize();
                        // Only push if inside
                         // pos.add(dir.multiplyScalar(0.05));
                         // Note: Strict collision for complex rotated shapes is heavy.
                         // For this "Parkour" style, allowing slight clip is better than getting stuck,
                         // as long as floor detection is perfect (which Raycast solves).
                    }
                }
            }
        }

        function handleJump() {
            if(state.onGround) {
                state.velocity.y = JUMP_FORCE;
            } else if (checkForWall()) {
                state.velocity.y = WALL_JUMP_FORCE;
                const viewDir = new THREE.Vector3();
                camera.getWorldDirection(viewDir);
                state.velocity.x = -viewDir.x * 20;
                state.velocity.z = -viewDir.z * 20;
            }
        }

        // Decal Logic
        function createDecal(hit) {
            const object = hit.object;
            const position = hit.point.clone();
            const eye = new THREE.Vector3(0,0,0); // generic up
            const n = hit.face.normal.clone();
            n.transformDirection(object.matrixWorld);
            
            // Look at normal
            const m = new THREE.Matrix4();
            m.lookAt(position, position.clone().add(n), new THREE.Vector3(0,1,0)); // approximate rotation
            const rotation = new THREE.Euler().setFromRotationMatrix(m);

            const randomSize = 0.4 + Math.random() * 0.3;
            const size = new THREE.Vector3(randomSize, randomSize, 0.2);
            
            const decalGeo = new DecalGeometry(object, position, rotation, size);
            const decal = new THREE.Mesh(decalGeo, decalMat);
            scene.add(decal);
            
            setTimeout(() => { scene.remove(decal); decal.geometry.dispose(); }, DECAL_FADE_TIME);
        }

        let isAttacking = false;
        function attack() {
            if(isAttacking || window.isNight) return;
            isAttacking = true;

            // Mark stones
            attackRay.setFromCamera(new THREE.Vector2(0,0), camera);
            attackRay.far = 4;
            const hits = attackRay.intersectObjects(obstacles);
            if(hits.length > 0) createDecal(hits[0]);

            // Animation
            let t = 0;
            const startRot = -0.2; // Base rotation
            const anim = setInterval(() => {
                t += 0.25;
                // Simple chop animation
                handGroup.rotation.x = startRot - Math.sin(t) * 1.0; 
                handGroup.position.z = -0.6 - Math.sin(t) * 0.5;
                
                if(t >= Math.PI) {
                    clearInterval(anim);
                    isAttacking = false;
                }
            }, 16);
        }

        // Main Loop
        const clock = new THREE.Clock();
        
        function update() {
            requestAnimationFrame(update);
            const delta = Math.min(clock.getDelta(), 0.1);
            const time = clock.getElapsedTime();

            // 1. Stamina
            if(keys.shift && (keys.w||keys.a||keys.s||keys.d)) state.stamina = Math.max(0, state.stamina - 30*delta);
            else state.stamina = Math.min(100, state.stamina + 15*delta);
            document.getElementById('stamina-bar').style.width = state.stamina + '%';

            // 2. Speed / Crouch
            let speed = MOVESPEED;
            if(keys.shift && state.stamina > 0) speed = SPRINT_SPEED;
            
            if(keys.c) {
                state.cameraHeight = THREE.MathUtils.lerp(state.cameraHeight, 0.8, 0.1);
            } else {
                state.cameraHeight = THREE.MathUtils.lerp(state.cameraHeight, 1.7, 0.1);
            }
            camera.position.y = state.cameraHeight;

            // 3. Movement
            const forward = new THREE.Vector3(0, 0, -1).applyAxisAngle(new THREE.Vector3(0,1,0), playerBody.rotation.y);
            const right = new THREE.Vector3(1, 0, 0).applyAxisAngle(new THREE.Vector3(0,1,0), playerBody.rotation.y);
            
            const moveDir = new THREE.Vector3();
            if(keys.w) moveDir.add(forward);
            if(keys.s) moveDir.sub(forward);
            if(keys.d) moveDir.add(right);
            if(keys.a) moveDir.sub(right);
            if(moveDir.length() > 0) moveDir.normalize();

            state.velocity.x = THREE.MathUtils.lerp(state.velocity.x, moveDir.x * speed, 0.1);
            state.velocity.z = THREE.MathUtils.lerp(state.velocity.z, moveDir.z * speed, 0.1);
            state.velocity.y -= GRAVITY * delta;

            // Apply Velocity
            playerBody.position.x += state.velocity.x * delta;
            playerBody.position.z += state.velocity.z * delta;
            playerBody.position.y += state.velocity.y * delta;

            // 4. Ground Collision (Raycast)
            const groundY = getGroundHeight(playerBody.position);
            
            // Simple tolerance for landing
            if (playerBody.position.y < groundY + PLAYER_HEIGHT) {
                playerBody.position.y = groundY + PLAYER_HEIGHT;
                state.velocity.y = 0;
                state.onGround = true;
            } else {
                state.onGround = false;
            }

            // 5. Weapon Sway / Torch Dynamics
            const targetHandX = 0.5;
            const targetHandY = -0.5;
            
            // Smoothly return hand to center
            handGroup.position.x = THREE.MathUtils.lerp(handGroup.position.x, targetHandX, 0.1);
            handGroup.position.y = THREE.MathUtils.lerp(handGroup.position.y, targetHandY, 0.1);

            // Breathing/Walking Bob
            if(!isAttacking) {
                handGroup.position.y += Math.sin(time * 2) * 0.005;
                if((keys.w||keys.a||keys.s||keys.d) && state.onGround) {
                    // Walking Bob
                    handGroup.position.y += Math.sin(time * 12) * 0.02;
                    handGroup.position.x += Math.cos(time * 12) * 0.01;
                }
                
                // Return rotation to neutral
                if (window.isNight) {
                    // Torch hold pose (slightly angled)
                     handGroup.rotation.x = THREE.MathUtils.lerp(handGroup.rotation.x, -0.2, 0.1);
                } else {
                    handGroup.rotation.x = THREE.MathUtils.lerp(handGroup.rotation.x, 0, 0.1);
                }
            }
            
            // Dynamic Torch Flicker
            if (window.isNight && torchLight) {
                torchLight.intensity = TORCH_LIGHT_INTENSITY + Math.random() * 2;
            }

            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        update();
    </script>
</body>
</html>