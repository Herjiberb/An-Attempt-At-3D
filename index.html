<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3rd Person RPG - Three.js</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #87CEEB; }
        #loading { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: white; font-family: sans-serif; pointer-events: none; }
    </style>
</head>
<body>
    <div id="loading">Loading World...</div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // --- CONFIGURATION ---
        const SETTINGS = {
            speed: 10,
            jumpForce: 15,
            gravity: 30,
            turnSpeed: 10,
            cameraHeight: 4,
            cameraDistance: 8
        };

        // --- SCENE SETUP ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87CEEB); // Sky Blue
        scene.fog = new THREE.FogExp2(0x87CEEB, 0.02); // Depth fog

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderer.domElement);

        // --- LIGHTING ---
        const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 0.6);
        scene.add(hemiLight);

        const dirLight = new THREE.DirectionalLight(0xffffff, 1.2);
        dirLight.position.set(50, 100, 50);
        dirLight.castShadow = true;
        dirLight.shadow.mapSize.width = 2048;
        dirLight.shadow.mapSize.height = 2048;
        dirLight.shadow.camera.near = 0.5;
        dirLight.shadow.camera.far = 500;
        dirLight.shadow.camera.left = -50;
        dirLight.shadow.camera.right = 50;
        dirLight.shadow.camera.top = 50;
        dirLight.shadow.camera.bottom = -50;
        scene.add(dirLight);

        // --- TERRAIN GENERATION (Green Hills) ---
        // We use a math function to determine height so we can "walk" on it easily
        function getTerrainHeight(x, z) {
            // Simple sine wave combination for hills
            return (Math.sin(x * 0.1) * 2) + (Math.cos(z * 0.1) * 2) + (Math.sin(x * 0.3 + z * 0.2) * 1);
        }

        const planeGeometry = new THREE.PlaneGeometry(200, 200, 100, 100);
        planeGeometry.rotateX(-Math.PI / 2);
        
        // Apply height map to vertices
        const posAttribute = planeGeometry.attributes.position;
        for (let i = 0; i < posAttribute.count; i++) {
            const x = posAttribute.getX(i);
            const z = posAttribute.getZ(i);
            const y = getTerrainHeight(x, z);
            posAttribute.setY(i, y);
        }
        planeGeometry.computeVertexNormals();

        const planeMaterial = new THREE.MeshStandardMaterial({ 
            color: 0x55aa55, // Green
            roughness: 0.8,
            metalness: 0.1,
            side: THREE.DoubleSide
        });
        const terrain = new THREE.Mesh(planeGeometry, planeMaterial);
        terrain.receiveShadow = true;
        scene.add(terrain);

        // --- PLAYER SYSTEM ---
        const playerGroup = new THREE.Group();
        scene.add(playerGroup);

        // Placeholder Character (Capsule) - REPLACED BY GLB LATER
        const playerGeo = new THREE.CapsuleGeometry(0.5, 1, 4, 8);
        const playerMat = new THREE.MeshStandardMaterial({ color: 0xff0000 });
        const playerMesh = new THREE.Mesh(playerGeo, playerMat);
        playerMesh.position.y = 1; 
        playerMesh.castShadow = true;
        playerGroup.add(playerMesh); // Add mesh to the group

        // Weapon Placeholder Holder
        const handGroup = new THREE.Group();
        handGroup.position.set(0.6, 1, 0.4); // Position relative to player center
        playerGroup.add(handGroup);

        // --- ASSET LOADING LOGIC ---
        // This is where you swap the placeholder for your real files
        const loader = new GLTFLoader();
        let mixer; // Animation Mixer
        
        const weapons = {
            current: 0,
            list: ['BattleAxe.glb', 'Sword.glb', 'Pickaxe.glb'], // Your files
            meshes: []
        };

        // Function to load actual models (Call this to activate real assets)
        function loadAssets() {
            // 1. Load Player
            /* loader.load('./Player.glb', (gltf) => {
                const model = gltf.scene;
                model.traverse(c => { if(c.isMesh) c.castShadow = true; });
                
                // Remove placeholder
                playerGroup.remove(playerMesh);
                playerGroup.add(model);
                
                // Setup Animations
                mixer = new THREE.AnimationMixer(model);
                // const action = mixer.clipAction(gltf.animations[0]); // Run/Idle
                // action.play();
                
                // FIND HAND BONE (Crucial for weapons)
                // You must check Blender for exact bone name, usually 'RightHand' or 'mixamorigRightHand'
                // const handBone = model.getObjectByName('RightHand'); 
                // if(handBone) handBone.add(handGroup); // Attach weapon holder to bone
                
                document.getElementById('loading').style.display = 'none';
            });
            */

           // 2. Load Weapons (Simulated with boxes for now)
           const createWeapon = (color) => {
               const geo = new THREE.BoxGeometry(0.2, 0.2, 1);
               const mat = new THREE.MeshStandardMaterial({ color: color });
               return new THREE.Mesh(geo, mat);
           };
           
           // Simulating loaded GLBs with primitives
           weapons.meshes.push(createWeapon(0xffd700)); // Axe (Gold)
           weapons.meshes.push(createWeapon(0xc0c0c0)); // Sword (Silver)
           weapons.meshes.push(createWeapon(0x8b4513)); // Pickaxe (Brown)
           
           // Add first weapon
           handGroup.add(weapons.meshes[0]);
           document.getElementById('loading').style.display = 'none';
        }

        loadAssets(); // Start loading

        // --- CONTROLS ---
        const keys = { w: false, a: false, s: false, d: false, space: false };
        const playerVelocity = new THREE.Vector3();
        let isGrounded = false;
        let isAttacking = false;

        window.addEventListener('keydown', (e) => {
            const key = e.key.toLowerCase();
            if (keys.hasOwnProperty(key)) keys[key] = true;
            if (e.code === 'Space') keys.space = true;
        });

        window.addEventListener('keyup', (e) => {
            const key = e.key.toLowerCase();
            if (keys.hasOwnProperty(key)) keys[key] = false;
            if (e.code === 'Space') keys.space = false;
        });

        // Mouse Click to Attack
        window.addEventListener('mousedown', () => {
            if(!isAttacking) {
                isAttacking = true;
                
                // Attack Animation Logic
                const weapon = handGroup.children[0];
                if(weapon) {
                    // Simple swing animation via Tweening logic (manual)
                    let startRot = weapon.rotation.x;
                    let duration = 0;
                    const swing = () => {
                        duration += 0.1;
                        weapon.rotation.x = startRot - Math.sin(duration * Math.PI) * 2; // Swing down
                        if(duration < 1) requestAnimationFrame(swing);
                        else {
                            weapon.rotation.x = startRot;
                            isAttacking = false;
                            
                            // Swap Weapon on attack finish (just to show functionality)
                            swapWeapon();
                        }
                    };
                    swing();
                }
            }
        });

        function swapWeapon() {
            handGroup.remove(handGroup.children[0]);
            weapons.current = (weapons.current + 1) % weapons.meshes.length;
            handGroup.add(weapons.meshes[weapons.current]);
            console.log("Swapped to: " + weapons.list[weapons.current]);
        }

        // --- GAME LOOP ---
        const clock = new THREE.Clock();
        const tempVector = new THREE.Vector3();

        function animate() {
            requestAnimationFrame(animate);
            
            const delta = Math.min(clock.getDelta(), 0.1); // Cap delta to prevent huge jumps
            
            if (mixer) mixer.update(delta);

            // 1. Movement Logic relative to Camera
            const moveSpeed = SETTINGS.speed;
            
            // Get camera direction but ignore Y (flat movement)
            const camForward = new THREE.Vector3();
            camera.getWorldDirection(camForward);
            camForward.y = 0;
            camForward.normalize();
            
            const camRight = new THREE.Vector3();
            camRight.crossVectors(camForward, new THREE.Vector3(0, 1, 0));

            // Calculate input direction
            const inputDir = new THREE.Vector3();
            if (keys.w) inputDir.add(camForward);
            if (keys.s) inputDir.sub(camForward);
            if (keys.a) inputDir.sub(camRight);
            if (keys.d) inputDir.add(camRight);

            if (inputDir.length() > 0) {
                inputDir.normalize();
                
                // Accelerate
                playerVelocity.x = inputDir.x * moveSpeed;
                playerVelocity.z = inputDir.z * moveSpeed;

                // Rotate player to face movement direction
                const targetRotation = Math.atan2(inputDir.x, inputDir.z);
                // Smooth rotation
                const currentRotation = playerGroup.rotation.y;
                let diff = targetRotation - currentRotation;
                // Normalize angle
                while (diff > Math.PI) diff -= Math.PI * 2;
                while (diff < -Math.PI) diff += Math.PI * 2;
                playerGroup.rotation.y += diff * SETTINGS.turnSpeed * delta;

            } else {
                // Decelerate / Friction
                playerVelocity.x *= 0.8;
                playerVelocity.z *= 0.8;
            }

            // 2. Gravity and Jumping
            playerVelocity.y -= SETTINGS.gravity * delta;

            // Apply Velocity
            playerGroup.position.x += playerVelocity.x * delta;
            playerGroup.position.z += playerVelocity.z * delta;
            playerGroup.position.y += playerVelocity.y * delta;

            // 3. Terrain Collision
            const terrainHeight = getTerrainHeight(playerGroup.position.x, playerGroup.position.z);
            
            if (playerGroup.position.y < terrainHeight) {
                playerGroup.position.y = terrainHeight;
                playerVelocity.y = 0;
                isGrounded = true;
            } else {
                isGrounded = false;
            }

            if (keys.space && isGrounded) {
                playerVelocity.y = SETTINGS.jumpForce;
                isGrounded = false;
            }

            // 4. Camera Follow
            // Calculate ideal camera position (Behind and above player)
            const camOffset = new THREE.Vector3(0, SETTINGS.cameraHeight, -SETTINGS.cameraDistance);
            camOffset.applyAxisAngle(new THREE.Vector3(0, 1, 0), playerGroup.rotation.y); // Rotate offset with player? Or keep it mouse controlled?
            
            // For true 3rd person RPG, usually camera rotates independently (Mouse), 
            // but for simple WASD, let's keep camera fixed behind or use a simple offset logic:
            
            const targetPos = playerGroup.position.clone().add(new THREE.Vector3(0, SETTINGS.cameraHeight, SETTINGS.cameraDistance));
            // Lerp camera for smoothness
            camera.position.lerp(targetPos, 0.1);
            camera.lookAt(playerGroup.position.clone().add(new THREE.Vector3(0, 2, 0))); // Look slightly above feet

            renderer.render(scene, camera);
        }

        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();
    </script>
</body>
</html>
