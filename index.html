<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FPS Parkour - Infinite</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #1a1a1a; user-select: none; }
        #hud {
            position: absolute; bottom: 20px; left: 20px; width: 300px;
            font-family: 'Segoe UI', sans-serif; pointer-events: none;
        }
        .bar-container {
            width: 100%; height: 20px; background: rgba(0,0,0,0.5);
            margin-bottom: 5px; border: 2px solid #555;
        }
        #stamina-bar { width: 100%; height: 100%; background: #00ffcc; transition: width 0.1s; }
        #crosshair {
            position: absolute; top: 50%; left: 50%; width: 10px; height: 10px;
            background: white; border-radius: 50%; transform: translate(-50%, -50%);
            mix-blend-mode: difference; pointer-events: none;
        }
        #instructions {
            position: absolute; top: 20px; right: 20px; text-align: right;
            color: rgba(255, 255, 255, 0.7); font-family: monospace; pointer-events: none;
        }
        #loading {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: #00ffcc; font-family: sans-serif; font-size: 24px; font-weight: bold;
            text-shadow: 0 0 10px #00ffcc;
        }
    </style>
</head>
<body>
    <div id="crosshair"></div>
    <div id="loading">GENERATING WORLD...</div>
    
    <div id="hud">
        <div style="color:white; margin-bottom:5px;">STAMINA</div>
        <div class="bar-container"><div id="stamina-bar"></div></div>
        <div id="weapon-name" style="color:white; font-size: 14px;">FISTS</div>
    </div>

    <div id="instructions">
        WASD - Move<br>
        SHIFT - Sprint (Hold)<br>
        SPACE - Jump / Wall Jump<br>
        C - Slide / Crouch<br>
        L-CLICK - Attack/Mark Stone<br>
        R-CLICK - Switch Weapon
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { DecalGeometry } from 'three/addons/geometries/DecalGeometry.js'; // Decal import

        // --- CONFIGURATION ---
        const SEED = 888;
        const CHUNK_SIZE = 100;
        const MOVESPEED = 12;
        const SPRINT_SPEED = 22;
        const JUMP_FORCE = 18;
        const GRAVITY = 40;
        const WALL_JUMP_FORCE = 25;
        const PLAYER_HALF_HEIGHT = 0.85; // Player stands at 1.7 height
        const PLAYER_RADIUS = 0.5; // Arbitrary radius for horizontal collision
        const DECAL_FADE_TIME = 15000; // 15 seconds in milliseconds
        
        // --- GAME STATE ---
        const state = {
            stamina: 100,
            isSprinting: false,
            isSliding: false,
            canWallJump: false,
            onGround: false,
            velocity: new THREE.Vector3(),
            cameraHeight: 1.7
        };

        // --- SCENE SETUP ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87CEEB); // Sky
        scene.fog = new THREE.Fog(0x87CEEB, 10, 90);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true; // Shadows enabled
        document.body.appendChild(renderer.domElement);

        // Lighting
        const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 1.0);
        scene.add(hemiLight);
        const dirLight = new THREE.DirectionalLight(0xffffff, 1.0);
        dirLight.position.set(50, 100, 50);
        dirLight.castShadow = true;
        // Configure shadow properties
        dirLight.shadow.mapSize.width = 2048;
        dirLight.shadow.mapSize.height = 2048;
        dirLight.shadow.camera.near = 10;
        dirLight.shadow.camera.far = 200;
        dirLight.shadow.camera.left = -100;
        dirLight.shadow.camera.right = 100;
        dirLight.shadow.camera.top = 100;
        dirLight.shadow.camera.bottom = -100;
        scene.add(dirLight);

        // --- PLAYER CONTROLLER OBJECTS ---
        const playerBody = new THREE.Group();
        scene.add(playerBody);
        
        playerBody.add(camera);
        camera.position.y = state.cameraHeight;

        // Weapon Holder (Attached to Camera so it moves with view)
        const handGroup = new THREE.Group();
        handGroup.position.set(0.5, -0.4, -0.8); // Bottom right of screen
        handGroup.rotation.set(0, -0.2, 0); // Slight tilt
        camera.add(handGroup);

        // --- ASSETS ---
        const loader = new GLTFLoader();
        const weapons = [];
        let currentWeaponIdx = -1;

        async function loadAssets() {
            try {
                const playerGltf = await loader.loadAsync('./Player.glb');
                const pMesh = playerGltf.scene;
                pMesh.visible = false;
                playerBody.add(pMesh);

                const files = ['BattleAxe.glb', 'Sword.glb', 'Pickaxe.glb'];
                const names = ['Battle Axe', 'Sword', 'Pickaxe'];
                
                for(let i=0; i<files.length; i++) {
                    const gltf = await loader.loadAsync('./' + files[i]);
                    const w = gltf.scene;
                    
                    // Make the tool/weapon cast a shadow
                    w.traverse(child => {
                        if (child.isMesh) {
                            child.castShadow = true;
                        }
                    });

                    // Adjust scales/rotations to look good in First Person
                    if(names[i] === 'Sword') {
                        w.scale.set(1.5, 1.5, 1.5);
                        w.rotation.set(0, Math.PI/2, 0); 
                    } else if (names[i] === 'Battle Axe') {
                        w.scale.set(2, 2, 2);
                        w.rotation.set(0, Math.PI, 0);
                    } else {
                        w.scale.set(2, 2, 2);
                    }
                    
                    w.visible = false;
                    handGroup.add(w);
                    weapons.push({ mesh: w, name: names[i] });
                }

                if(weapons.length > 0) switchWeapon(0);
                document.getElementById('loading').style.display = 'none';

            } catch (e) {
                console.error(e);
                document.getElementById('loading').innerText = "Asset Error";
            }
        }
        loadAssets();

        function switchWeapon(idx) {
            if(weapons.length === 0) return;
            weapons.forEach(w => w.mesh.visible = false);
            
            if(idx === -1) idx = 0;
            currentWeaponIdx = idx % weapons.length;
            
            weapons[currentWeaponIdx].mesh.visible = true;
            document.getElementById('weapon-name').innerText = weapons[currentWeaponIdx].name;

            handGroup.position.y = -0.8;
        }

        // --- TERRAIN & STONEHENGE GENERATION ---
        const textureLoader = new THREE.TextureLoader();
        
        // Load and configure Textures
        const stoneTexture = textureLoader.load('./Stone.jpg');
        stoneTexture.wrapS = stoneTexture.wrapT = THREE.RepeatWrapping;
        stoneTexture.repeat.set(5, 5); 
        
        const grassTexture = textureLoader.load('./Grass.jpg');
        grassTexture.wrapS = grassTexture.wrapT = THREE.RepeatWrapping;
        grassTexture.repeat.set(50, 50); 
        
        const brokenStoneTexture = textureLoader.load('./BrokenStone.jpg');
        brokenStoneTexture.wrapS = brokenStoneTexture.wrapT = THREE.RepeatWrapping;
        
        const mudTexture = textureLoader.load('./Mud.jpg');
        mudTexture.wrapS = mudTexture.wrapT = THREE.RepeatWrapping;

        // Materials
        const stoneMat = new THREE.MeshStandardMaterial({ map: stoneTexture, roughness: 0.7, metalness: 0.1 });
        const terrainMat = new THREE.MeshStandardMaterial({ map: grassTexture });
        
        // Decal Material (for impact marks)
        const brokenDecalMat = new THREE.MeshStandardMaterial({
            map: brokenStoneTexture,
            transparent: true,
            depthTest: true,
            depthWrite: false,
            polygonOffset: true,
            polygonOffsetFactor: -4, // Push decal slightly in front of object
            roughness: 0.9,
        });

        // Mud Material (for puddles)
        const mudMat = new THREE.MeshStandardMaterial({
            map: mudTexture,
            transparent: true,
            opacity: 0.9,
            roughness: 0.5,
            metalness: 0.2
        });


        // Helper noise function
        function noise(x, z) {
            return (Math.sin(x * 0.05 + SEED) + Math.cos(z * 0.05 + SEED)) * 2;
        }

        // 1. Setup Terrain Mesh
        const worldGeo = new THREE.PlaneGeometry(300, 300, 100, 100);
        worldGeo.rotateX(-Math.PI/2);
        const posAttr = worldGeo.attributes.position;
        for(let i=0; i<posAttr.count; i++) {
            const x = posAttr.getX(i);
            const z = posAttr.getZ(i);
            let y = noise(x, z) * 2;
            if(y < -2) y = -2;
            posAttr.setY(i, y);
        }
        worldGeo.computeVertexNormals();
        
        const terrain = new THREE.Mesh(worldGeo, terrainMat);
        terrain.receiveShadow = true;
        scene.add(terrain);

        // Parkour Obstacles Array (for collision detection)
        const obstacles = [];

        // Helper to get terrain height only
        function getRawTerrainY(x, z) {
            let terrainY = noise(x, z) * 2;
            if(terrainY < -2) terrainY = -2;
            return terrainY;
        }

        function createBlock(x, z, w, h, d) {
            const geo = new THREE.BoxGeometry(w, h, d);
            
            // Texture mapping: scale texture repetition based on block size
            const repeatX = w / 5; 
            const repeatY = h / 5;
            const repeatZ = d / 5;
            
            const uvs = geo.attributes.uv.array;
            // Simplified UV setup for infinite wrap look (applied to all faces)
            for (let i = 0; i < uvs.length; i += 2) {
                uvs[i] *= repeatX; 
                uvs[i+1] *= repeatY; 
            }
            geo.attributes.uv.needsUpdate = true;
            
            const mesh = new THREE.Mesh(geo, stoneMat.clone()); 
            
            // Proper placement: base is on the terrain
            const terrainBaseY = getRawTerrainY(x, z); 
            mesh.position.set(x, terrainBaseY + h/2, z); 
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            scene.add(mesh);
            obstacles.push(mesh);
            
            // Add bounding box for physics and game properties
            mesh.userData.box = new THREE.Box3().setFromObject(mesh);
            mesh.userData.isBlock = true; // Identify as a block
            mesh.userData.isBreakable = true; // All blocks are breakable targets for decals
            return mesh;
        }

        function generateStonehenge(cx, cz) {
            const radius = 15;
            const count = 8;
            for(let i=0; i<count; i++) {
                const angle = (i / count) * Math.PI * 2;
                const x = cx + Math.cos(angle) * radius;
                const z = cz + Math.sin(angle) * radius;
                
                // Tall pillar
                const pillar = createBlock(x, z, 2, 8 + Math.random()*4, 2);
                pillar.userData.isBreakable = false; // Make large structures immune to removal

                // Lintel (connecting top)
                if(Math.random() > 0.5) {
                    const nextAngle = ((i+1) / count) * Math.PI * 2;
                    const nx = cx + Math.cos(nextAngle) * radius;
                    const nz = cz + Math.sin(nextAngle) * radius;
                    const midX = (x + nx) / 2;
                    const midZ = (z + nz) / 2;
                    
                    const blockHeight = 1;
                    const bridge = createBlock(midX, midZ, 2, blockHeight, 10);
                    bridge.position.y = getRawTerrainY(midX, midZ) + 10 + blockHeight/2;
                    bridge.lookAt(x, bridge.position.y, z);
                    bridge.userData.isBreakable = false; // Lintels immune
                }
            }
            
            // Center jumping block (small jumpable block can be marked/removed)
            createBlock(cx, cz, 4, 3, 4);
        }

        function generateMudPuddles(count) {
            const range = 150;
            for (let i = 0; i < count; i++) {
                const x = (Math.random() - 0.5) * range;
                const z = (Math.random() - 0.5) * range;
                const y = getRawTerrainY(x, z) + 0.01; // Slightly above terrain

                // Use a thin cylinder/plane for the puddle
                const puddleGeo = new THREE.CircleGeometry(3 + Math.random() * 2, 16);
                puddleGeo.rotateX(-Math.PI / 2);
                
                const puddle = new THREE.Mesh(puddleGeo, mudMat);
                puddle.position.set(x, y, z);
                puddle.rotation.y = Math.random() * Math.PI * 2;
                puddle.receiveShadow = true;
                scene.add(puddle);
            }
        }

        // Generate world
        generateStonehenge(0, -30);
        generateStonehenge(50, 50);
        generateStonehenge(-50, 40);
        generateMudPuddles(30); // Create 30 mud puddles

        // --- INPUTS ---
        const keys = { w:false, a:false, s:false, d:false, space:false, shift:false, c:false };
        
        // Pointer Lock
        document.body.addEventListener('click', (e) => {
            if(document.pointerLockElement !== document.body) {
                document.body.requestPointerLock();
            } else {
                if(e.button === 0) attack();
                if(e.button === 2) switchWeapon(currentWeaponIdx + 1);
            }
        });

        document.addEventListener('mousemove', (e) => {
            if(document.pointerLockElement === document.body) {
                playerBody.rotation.y -= e.movementX * 0.002;
                camera.rotation.x -= e.movementY * 0.002;
                camera.rotation.x = Math.max(-1.5, Math.min(1.5, camera.rotation.x));
            }
        });

        window.addEventListener('keydown', (e) => {
            const k = e.key.toLowerCase();
            if(keys.hasOwnProperty(k)) keys[k] = true;
            if(e.code === 'Space') {
                keys.space = true;
                handleJump();
            }
            if(e.shiftKey) keys.shift = true;
        });
        
        window.addEventListener('keyup', (e) => {
            const k = e.key.toLowerCase();
            if(keys.hasOwnProperty(k)) keys[k] = false;
            if(e.code === 'Space') keys.space = false;
            if(!e.shiftKey) keys.shift = false;
        });

        // --- PHYSICS & LOGIC ---
        let isAttacking = false;
        
        // Helper function to create and time the removal of a decal
        function createDecal(hit) {
            const object = hit.object;
            const position = hit.point.clone();
            const orientation = new THREE.Euler().setFromQuaternion(new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0, 0, 1), hit.face.normal));
            
            // Decal size (small impact mark)
            const size = new THREE.Vector3(1, 1, 1).multiplyScalar(0.5 + Math.random() * 0.5); 
            
            const decalGeometry = new DecalGeometry(object, position, orientation, size);
            const decal = new THREE.Mesh(decalGeometry, brokenDecalMat);
            
            scene.add(decal);

            // Set up removal timer
            setTimeout(() => {
                scene.remove(decal);
                decal.geometry.dispose();
                // Decal material is shared, no need to dispose
            }, DECAL_FADE_TIME);
        }

        function attack() {
            if(isAttacking) return;
            isAttacking = true;

            // 1. Raycast for stone marking
            const raycaster = new THREE.Raycaster();
            const center = new THREE.Vector2(0, 0);
            raycaster.setFromCamera(center, camera);
            raycaster.far = 5; // Interaction range
            
            const hits = raycaster.intersectObjects(obstacles);
            if (hits.length > 0) {
                const block = hits[0].object;
                if (block.userData.isBlock) {
                    // Create an impact mark (decal)
                    createDecal(hits[0]);
                }
            }

            // 2. Weapon animation
            const startZ = handGroup.position.z;
            const startRot = handGroup.rotation.x;
            
            let t = 0;
            const anim = setInterval(() => {
                t += 0.2;
                handGroup.position.z = startZ - Math.sin(t) * 0.5; 
                handGroup.rotation.x = startRot - Math.sin(t) * 0.5;
                
                if(t >= Math.PI) {
                    clearInterval(anim);
                    handGroup.position.z = startZ;
                    handGroup.rotation.x = startRot;
                    isAttacking = false;
                }
            }, 16);
        }

        function handleJump() {
            if(state.onGround) {
                state.velocity.y = JUMP_FORCE;
            } 
            else if (checkForWall()) {
                state.velocity.y = WALL_JUMP_FORCE;
                const viewDir = new THREE.Vector3();
                camera.getWorldDirection(viewDir);
                state.velocity.x = -viewDir.x * 20;
                state.velocity.z = -viewDir.z * 20;
            }
        }

        const raycaster = new THREE.Raycaster();
        
        function checkForWall() {
            const dir = new THREE.Vector3();
            camera.getWorldDirection(dir);
            raycaster.set(playerBody.position, dir);
            raycaster.far = 2.0; 
            const hits = raycaster.intersectObjects(obstacles);
            return hits.length > 0;
        }

        // Corrected function to find actual ground height (terrain or block top)
        function getActualGroundY(x, z) {
            let groundY = getRawTerrainY(x, z); 
            
            for(let ob of obstacles) {
                const box = ob.userData.box;
                if(x >= box.min.x && x <= box.max.x && z >= box.min.z && z <= box.max.z) {
                    // Check if player is not currently deep inside the block (prevents teleporting up)
                    if (playerBody.position.y < box.max.y + PLAYER_HALF_HEIGHT + 0.1) {
                         // Only consider it 'ground' if the block top is below the player
                        if(box.max.y > groundY && box.max.y <= playerBody.position.y + 0.1) {
                            groundY = box.max.y;
                        }
                    }
                }
            }
            return groundY;
        }
        
        // Horizontal Collision Check 
        function checkHorizontalCollision(currentPos, newPos, radius) {
            const nextBox = new THREE.Box3(
                new THREE.Vector3(newPos.x - radius, newPos.y - PLAYER_HALF_HEIGHT, newPos.z - radius),
                new THREE.Vector3(newPos.x + radius, newPos.y + PLAYER_HALF_HEIGHT, newPos.z + radius)
            );
            
            for (let ob of obstacles) {
                const obBox = ob.userData.box;
                if (nextBox.intersectsBox(obBox)) {
                     // Only register collision if the player is hitting the side, not already standing on top
                     if (currentPos.y < obBox.max.y) {
                        return true;
                     }
                }
            }
            return false;
        }

        const clock = new THREE.Clock();

        function update() {
            requestAnimationFrame(update);
            const delta = Math.min(clock.getDelta(), 0.1);

            // 1. Stamina Logic
            if(keys.shift && (keys.w || keys.a || keys.s || keys.d)) {
                state.stamina = Math.max(0, state.stamina - 30 * delta);
            } else {
                state.stamina = Math.min(100, state.stamina + 15 * delta);
            }
            document.getElementById('stamina-bar').style.width = state.stamina + '%';

            // 2. Speed Calculation and Crouch/Slide
            let speed = MOVESPEED;
            if(keys.shift && state.stamina > 0) speed = SPRINT_SPEED;
            if(keys.c) { 
                state.cameraHeight = THREE.MathUtils.lerp(state.cameraHeight, 0.8, 0.2); 
                if(speed > MOVESPEED) speed += 5; 
            } else {
                state.cameraHeight = THREE.MathUtils.lerp(state.cameraHeight, 1.7, 0.2); 
            }
            // Clamp camera height to prevent sinking
            camera.position.y = state.cameraHeight;


            // 3. Movement Input
            const forward = new THREE.Vector3(0, 0, -1).applyAxisAngle(new THREE.Vector3(0,1,0), playerBody.rotation.y);
            const right = new THREE.Vector3(1, 0, 0).applyAxisAngle(new THREE.Vector3(0,1,0), playerBody.rotation.y);
            
            const moveDir = new THREE.Vector3();
            if(keys.w) moveDir.add(forward);
            if(keys.s) moveDir.sub(forward);
            if(keys.d) moveDir.add(right);
            if(keys.a) moveDir.sub(right);
            
            if(moveDir.length() > 0) moveDir.normalize();

            // Apply inertia/slide
            state.velocity.x = THREE.MathUtils.lerp(state.velocity.x, moveDir.x * speed, keys.c ? 0.02 : 0.1);
            state.velocity.z = THREE.MathUtils.lerp(state.velocity.z, moveDir.z * speed, keys.c ? 0.02 : 0.1);

            // Gravity
            state.velocity.y -= GRAVITY * delta;
            
            const originalPos = playerBody.position.clone();
            let newX = originalPos.x + state.velocity.x * delta;
            let newZ = originalPos.z + state.velocity.z * delta;

            // 4. Horizontal Collision Check (prevents clipping through walls/blocks)
            
            // Check X movement
            const checkXPos = new THREE.Vector3(newX, originalPos.y, originalPos.z);
            if (!checkHorizontalCollision(originalPos, checkXPos, PLAYER_RADIUS)) {
                playerBody.position.x = newX;
            } else {
                state.velocity.x = 0; // Stop X movement on hit
            }
            
            // Check Z movement
            const checkZPos = new THREE.Vector3(playerBody.position.x, originalPos.y, newZ);
            if (!checkHorizontalCollision(originalPos, checkZPos, PLAYER_RADIUS)) {
                playerBody.position.z = newZ;
            } else {
                state.velocity.z = 0; // Stop Z movement on hit
            }

            // 5. Vertical Movement
            playerBody.position.y += state.velocity.y * delta;

            // 6. Vertical Collision (Ground)
            const groundH = getActualGroundY(playerBody.position.x, playerBody.position.z);
            const playerBaseY = playerBody.position.y - PLAYER_HALF_HEIGHT;
            
            if(playerBaseY < groundH) {
                playerBody.position.y = groundH + PLAYER_HALF_HEIGHT; // Set player center Y
                state.velocity.y = 0;
                state.onGround = true;
            } else {
                state.onGround = false;
            }


            // Weapon Sway (Idle/Run)
            const time = clock.getElapsedTime();
            if(!isAttacking) {
                handGroup.position.y = -0.4 + Math.sin(time * 2) * 0.02;
                handGroup.position.x = 0.5 + Math.cos(time * 1.5) * 0.02;
            }
            if((keys.w||keys.a||keys.s||keys.d) && state.onGround) {
                handGroup.position.y += Math.sin(time * 15) * 0.05;
            }
            
            // "Lerp" weapon back to position after attack
            if(!isAttacking) {
               handGroup.rotation.x = THREE.MathUtils.lerp(handGroup.rotation.x, 0, 0.1);
               handGroup.position.z = THREE.MathUtils.lerp(handGroup.position.z, -0.8, 0.1); 
            }

            renderer.render(scene, camera);
        }

        // Handle Resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        update();
    </script>
</body>
</html>